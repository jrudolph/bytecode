Anwendungen:

Compilerbackend
Optimierung(RegEx)->Compiler
Compilierung zur Laufzeit

Andere Moeglichkeiten:
Java + Compiler -> Nachteil zusaetzliche Stufe
CGLIB/ASM ->  


Gliederung:

1. EinfÃ¼hrendes Beispiel
2. Bytecode DSL Bibliothek
 * Typsicherheit durch Typenstack
 * Einfache (Unary) Operationen vs Binary- und mehr Operationen
 * Methodenreferenzen 
  * vorhandener Code: scala.reflect.Code[X => Y]
  * neuer Code
 * lokale Variablen, Variablenstack oder als einzelne Typparameter
3. Anwendung
 * XPath Compiler
 * Ersparnis/Performanceuntersuchung
4. Fazit

Referenzen:

XPath:

http://www.asciiarmor.com/2004/11/13/java-xpath-10-engine-comparison-performance/

Zu lesen:
 * http://elliotth.blogspot.com/2008/03/generating-jvm-bytecode.html
 * http://java.sun.com/docs/books/jvms/second_edition/html/VMSpecTOC.doc.html
   * insbesondere [http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#9308 Structural Constraints]
 * http://java-source.net/open-source/bytecode-libraries


Text
----
Safer Java Bytecode Generation using Scala Bytecode Library

To compile programs targetting the Java Virtual Machine, compiler writers have
to emit Java bytecodes, a serialized, binary form of the program. For this task
several libraries exist today. The well-formedness of the generated code is
checked when generating the code or when the JVM loads the code. Errors will be
reported at the runtime of the compiler. I propose a Scala library, which
doesn't even allow illegal bytecode sequences to be represented in terms of the
library. The library makes use of Scala's type system to let the Scala compiler
reject illegal combinations of bytecode operations. This is accomplished by
encoding the state of the stack and the local variables as type parameters of
an object representing the current frame.

