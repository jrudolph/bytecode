Proposal for diploma thesis of Johannes Rudolph

Safer Java Bytecode Generation: A Scala Bytecode Library
========================================================

To compile programs targetting the Java Virtual Machine(JVM), compiler writers
have to emit Java bytecodes, a serialized, binary form of the program. For this
task several libraries exist today. To enforce the well behaviour of the code,
the JVM specification defines several constraints which it imposes upon
bytecode.  The well-formedness of the generated code is then checked at
the time the JVM loads the code. 

Classes being rejected by the classloader are undesirable, so many
bytecode-generating libraries aid the compiler writer by giving him tools to
check if the generated code in spe is valid[2]. Using such a tool errors are
reported at the runtime of the compiler at least.

I propose a Scala library, which - in the best case - doesn't even allow
illegal bytecode sequences to be represented in terms of the library. The
library makes use of Scala's type system to let the Scala compiler reject
illegal combinations of bytecode operations. This is accomplished by encoding
the state of the stack and the local variables as type parameters of an object
representing the current state of the frame. By defining bytecode operations as
transitions between one type of frame and another one can enforce that only
matching operations can be applied to a given frame.

As an application of the library a tool will be developed which compiles an
XPath expression into a corresponding Java class which internally traverses the
DOM of an XML document.

Proposed thesis structure:
 1. Bytecode generation example (XPath or simple expression language)
 2. Summary of "Constraints on Java Virtual Machine Code"[1]
 3. Bytecode DSL
  * The Frame type: Building up stacks of types to represent stack and local variables of a method
  * Encoding of simple bytecode operations
  * Method calls
    * Using scala.reflect.Code to access information about existing methods
    * Forward references for code being defined (not yet sure how to do it)
  * Jumps: encoding of code references
  [* Translating Scala compiler errors into human readable form]
 4. Application: The XPath compiler
  * How it is done
  * Some performance measurements
 5. Discussion
 
[1] JVM Specs: http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#40222
[2] ASM Javadocs: http://asm.objectweb.org/asm31/javadoc/user/org/objectweb/asm/tree/analysis/Analyzer.html

Other documents:

Bytecode Libraries:
 * A list of libraries: http://java-source.net/open-source/bytecode-libraries
 * http://elliotth.blogspot.com/2008/03/generating-jvm-bytecode.html

XPath:
 * http://www.asciiarmor.com/2004/11/13/java-xpath-10-engine-comparison-performance/
 * http://www.ibm.com/developerworks/library/x-javaxpathapi.html#listing3
 * http://dom4j.org/benchmarks/xpath/index.html
 * http://www.nearinfinity.com/blogs/page/sfarley?entry=gpath_versus_xpath

Roadmap:
 July, 1st - 15th: Defining the core classes (subset of opcodes)
 July, 31th: Working byte code generation for that subset
 Aug XPath Compilation
 Sep XPath performance tests, adding missing opcodes, cleanup of the library
 Oct Writing Chap 2,3
 Nov Writing Chap 1,4,5
 Dec Finishing: proof-reading etc, buffer for unexpected events...
