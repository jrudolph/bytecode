Bottom: a3581845ad1fba496b27a54eaf9487e827bb5f08
Top:    88367aa8e4009f03a32ebac3444408f99e3b2b43
Author: Johannes Rudolph <johannes_rudolph@gmx.de>
Date:   2010-05-29 16:14:33 +0200

sprinkle some position information into the error messages


---

diff --git a/objectformatter/src/main/scala/net/virtualvoid/string/EnhancedStringsPlugin.scala b/objectformatter/src/main/scala/net/virtualvoid/string/EnhancedStringsPlugin.scala
index f002af2..79035ab 100644
--- a/objectformatter/src/main/scala/net/virtualvoid/string/EnhancedStringsPlugin.scala
+++ b/objectformatter/src/main/scala/net/virtualvoid/string/EnhancedStringsPlugin.scala
@@ -29,6 +29,7 @@ class EnhancedStringsPlugin(val global: Global) extends Plugin {
 	  def newTransformer(unit: CompilationUnit) = new ESTransformer(unit)
     
     class ESTransformer(unit: CompilationUnit) extends TypingTransformer(unit) {
+        localTyper = analyzer.newTyper(analyzer.rootContext(unit, EmptyTree, false))
 		val it = ValDef(Modifiers(Flags.PARAM), "it", TypeTree(), EmptyTree)
       
 	    /** When using <code>preTransform</code>, each node is
@@ -37,16 +38,21 @@ class EnhancedStringsPlugin(val global: Global) extends Plugin {
 	    def preTransform(tree: Tree): Tree = tree match {
 	      case _ => tree
 	    }
+	    def compiled(els:AST.FormatElementList, pos: Position): Tree = {
+	    
+	      def startOf(e: AST.Exp): Position = pos.withPoint(pos.startOrPoint + e.pos.column)
+	      def compile(els: AST.FormatElementList): Tree = compiled(els, pos)
+	    
 	    def compileParentExpressionInner(inner:AST.Exp,outer:Tree):Tree = inner match {
 	      case AST.ParentExp(inner,parent) => compileParentExpressionInner(inner,Select(outer,parent))
 	      case _ => inner match {case AST.Exp(id) => Select(outer,id)}
 	    }
      
-	    def compileExpression(exp:AST.Exp):Tree = exp match{
+	    def compileExpression(exp:AST.Exp):Tree = atPos(startOf(exp)) { exp match {
 	      case AST.ThisExp => Ident("it")
 	      case AST.ParentExp(inner,parent) => compileParentExpressionInner(inner,Ident(parent))
 	      case _ => exp match {case AST.Exp(identifier) => Ident(identifier)}
-	    }
+	    }}
 	    def compileElement(el:AST.FormatElement):Tree = el match{
 	      case AST.Literal(str) => Literal(Constant(str))
 	      case AST.ToStringConversion(exp) => Select(compileExpression(exp),"toString")
@@ -61,25 +67,26 @@ class EnhancedStringsPlugin(val global: Global) extends Plugin {
 	          CaseDef(Ident("None"),compile(elseEls))
 	        ))
 	    }
-	    def compile(els:AST.FormatElementList):Tree =
+	    
 	    	els.elements.size match {
 	    	  case 0 => Literal(Constant(""))
 	    	  case 1 => compileElement(els.elements(0))
 	    	  case _ => els.elements.map(compileElement _).reduceLeft((a,b)=>Apply(Select(a,"$plus"),List(b)))
 	    	}
-     
+        }
+        
 	    /** When using <code>postTransform</code>, each node is
 	     *  visited after its children.
 	     */
 	    def postTransform(tree: Tree): Tree = tree match {
 	      case This(qual) => {System.out.println(tree+":"+qual+qual.getClass+":"+qual.toString.length);tree}
 	      case Literal(Constant(str:String)) => 
+    	      
 	        try {
-	          typedPos(tree.pos)(compile(EnhancedStringFormatParser.parse(str)))
-	          //localTyper.typed(atPos(tree.pos){compile(EnhancedStringFormatParser.parse(str))})
+	          atPos(tree.pos)(compiled(EnhancedStringFormatParser.parse(str), tree.pos))
 	        } catch {
-	          case p:ParseException => error(p.getMessage);tree
-	          case e:TypeError => error(e.getMessage);tree
+	          case p:ParseException => p.printStackTrace;unit.error(tree.pos, p.getMessage);tree
+	          case e:TypeError => localTyper.reportTypeError(tree.pos, e);tree
 	        }
 	      case _ => tree
 	    }
