Bottom: bf84a8880291b0b2d04aed3562712337925e19ca
Top:    9d9699b35cdd60a546b85bc1e194a7961ec7d95f
Author: Johannes Rudolph <johannes_rudolph@gmx.de>
Date:   2010-11-22 08:14:34 +0100

new method calling syntax stub


---

diff --git a/bytecode/src/main/scala/net/virtualvoid/bytecode/Bytecode.scala b/bytecode/src/main/scala/net/virtualvoid/bytecode/Bytecode.scala
index 3369661..5d9e0c8 100644
--- a/bytecode/src/main/scala/net/virtualvoid/bytecode/Bytecode.scala
+++ b/bytecode/src/main/scala/net/virtualvoid/bytecode/Bytecode.scala
@@ -68,6 +68,7 @@ object Bytecode{
     def ldc[ST2>:ST<:List](str:jString):F[ST2**jString]
 
     def ~[X](f:F[ST]=>X):X = f(this)
+    def ~![ST2 >: ST <: List, Res <: List, X](m: Method[X])(implicit cons: Consumer[ST2, X, Res]): F[Res] = this.~(m.apply()(cons))
     
     def iadd_int[R<:List](rest:R,i1:Int,i2:Int):F[R**Int]
     def isub_int[R<:List](rest:R,i1:Int,i2:Int):F[R**Int]
@@ -112,10 +113,10 @@ object Bytecode{
     def store[ST<:List]:F[ST**T] => F[ST]
   }
 
-  import _root_.java.lang.reflect.Method
-  import _root_.scala.reflect.Manifest
+  import java.lang.reflect.{ Method => jMethod}
+  import scala.reflect.Manifest
 
-  abstract class MethodHandle(val method:Method){
+  abstract class MethodHandle(val method:jMethod){
     def numParams:Int
     
     protected def normalCall[X<:List,R<:List,U]:F[X]=>F[R**U] = _.invokemethod(this)
@@ -124,7 +125,34 @@ object Bytecode{
       nextF.pop_unit_int(nextF.stack.rest)
     }
   }
-  trait Method1[-T,+U] extends MethodHandle {
+
+  trait Res[+T]
+  trait Func[-T, +U]
+  type ~>:[T, U] = Func[T, U]
+  type <~[U, T] = Func[T, U]
+  trait Method[X] extends MethodHandle {
+    def apply[R <: List, Res <: List]()(implicit cons: Consumer[R, X, Res]): F[R] => F[Res] =
+      if (cons.isUnitCall) unitCall else normalCall.asInstanceOf[F[R]=>F[Res]]
+  }
+
+  type Method1[T, U] = Method[T ~>: Res[U]]
+  type Method2[T1, T2, U] = Method[Res[U] <~ T1 <~ T2]//Method[T2 ~>: T1 ~>: Res[U]]
+
+  /*trait Expand[T, F[_]] {
+    type R[V] = Func[T, F[V]]
+  }
+
+  Expand[Double, Expand[Int, Res]#R]#R
+
+  Func[Double, Func[Int, Res[String]]]
+
+  (Int ~~> Double)#R[String]
+
+  type ~~>[T, U] = Expand[U, Expand[T, Res]]#R
+ */
+
+  
+/*  trait Method1[-T,+U] extends MethodHandle {
     override val numParams = 1
     def invoke[R <: List, T1X <: T,UX >: U: NoUnit]():F[R**T1X] => F[R**UX] = normalCall
     def invokeUnit[R <: List, T1X <: T]()(implicit x: IsUnit[U]):F[R**T1X] => F[R] = unitCall
@@ -133,15 +161,16 @@ object Bytecode{
     override val numParams = 2
     def invoke[R <: List, T1X <: T1, T2X <: T2,UX >: U: NoUnit]():F[R**T1X**T2X] => F[R**UX] = normalCall
     def invokeUnit[R<:List,T1X<:T1,T2X<:T2]()(implicit x: IsUnit[U]):F[R**T1X**T2X] => F[R] = unitCall
-  }
+  }*/
   
-  implicit def normalCall1[R<:List, T, U: NoUnit](m:Method1[T,U]):F[R**T]=>F[R**U] = m.invoke()
-  implicit def unitCall1[R<:List,T](m:Method1[T,Unit]):F[R**T]=>F[R] = m.invokeUnit()
+  //implicit def consumeMethod[R <: List
+  //implicit def normalCall1[R<:List, T, U: NoUnit](m:Method1[T,U]):F[R**T]=>F[R**U] = m.invoke()
+  //implicit def unitCall1[R<:List,T](m:Method1[T,Unit]):F[R**T]=>F[R] = m.invokeUnit()
   
-  implicit def normalCall2[R <: List, T1, T2, U: NoUnit](m:Method2[T1,T2,U]):F[R**T1**T2]=>F[R**U] = m.invoke()
-  implicit def unitCall2[R<:List,T1,T2](m:Method2[T1,T2,Unit]):F[R**T1**T2]=>F[R] = m.invokeUnit()
+  //implicit def normalCall2[R <: List, T1, T2, U: NoUnit](m:Method2[T1,T2,U]):F[R**T1**T2]=>F[R**U] = m.invoke()
+  //implicit def unitCall2[R<:List,T1,T2](m:Method2[T1,T2,Unit]):F[R**T1**T2]=>F[R] = m.invokeUnit()
   
-  private def checkMethod[X](m:Method,retClazz:Class[_],paramClasses:Class[_]*)(f:Method=>X):X = {
+  private def checkMethod[X](m: jMethod, retClazz: Class[_], paramClasses: Class[_]*)(f: jMethod => X): X = {
     val params = if (CodeTools.static_?(m)) m.getParameterTypes() else (Array(m.getDeclaringClass) ++ m.getParameterTypes)
     
     def check(assertMsg:String)(condition:Boolean) = {
@@ -159,21 +188,67 @@ object Bytecode{
   }
   /** checks type information and returns a statically and dynamically safe handle
   */
-  def dynMethod[T,U](m:Method)(implicit p1:Manifest[T],r:Manifest[U]):Method1[T,U] =
-    checkMethod(m,r.erasure,p1.erasure)(new MethodHandle(_) with Method1[T,U])
-  def dynMethod[T,U](m:Method,p1:Class[T],r:Class[U]):Method1[T,U] =
+  def dynMethod[T,U](m: jMethod)(implicit p1: Manifest[T], r: Manifest[U]):Method1[T, U] =
+    checkMethod(m,r.erasure,p1.erasure)(new MethodHandle(_) with Method1[T, U]{ def numParams = 1 })
+  def dynMethod[T,U](m: jMethod, p1: Class[T], r: Class[U]): Method1[T, U] =
     dynMethod[T,U](m)(Manifest.classType(p1),Manifest.classType(r))
   
-  def method1[T,U](code:scala.reflect.Code[T=>U]):Method1[T,U] =
-    new MethodHandle(CodeTools.methodFromTree(code.tree)) with Method1[T,U]
+  def method1[T, U](code: scala.reflect.Code[T => U]): Method1[T, U] =
+    new MethodHandle(CodeTools.methodFromTree(code.tree)) with Method1[T, U] { def numParams = 1 }
   
-  def dynMethod[T1,T2,U](m:Method)(implicit p1:Manifest[T1],p2:Manifest[T1],r:Manifest[U]):Method2[T1,T2,U] =
-    checkMethod(m,r.erasure,p1.erasure,p2.erasure)(new MethodHandle(_) with Method2[T1,T2,U])
-  def dynMethod[T1,T2,U](m:Method,p1:Class[T1],p2:Class[T2],r:Class[U]):Method2[T1,T2,U] =
+  def dynMethod[T1,T2,U](m: jMethod)(implicit p1:Manifest[T1],p2:Manifest[T1],r:Manifest[U]):Method2[T1,T2,U] =
+    checkMethod(m,r.erasure,p1.erasure,p2.erasure)(new MethodHandle(_) with Method2[T1,T2,U] { def numParams = 2 })
+  def dynMethod[T1,T2,U](m: jMethod,p1:Class[T1],p2:Class[T2],r:Class[U]):Method2[T1,T2,U] =
     dynMethod[T1,T2,U](m)(Manifest.classType(p1),Manifest.classType(p2),Manifest.classType(r))
+
+  def method2[T1,T2,U](code:scala.reflect.Code[(T1,T2)=>U]): Method2[T1, T2, U] = 
+    new MethodHandle(CodeTools.methodFromCode(code)) with Method2[T1,T2,U] { def numParams = 2 }  
+  
+  trait Consumer[From <: List, Func, To <: List] {
+    def isUnitCall: Boolean
+    def depth: Int
+  }
+  class ResConsumer[From <: List, Func, To <: List](override val isUnitCall: Boolean) extends Consumer[From, Func, To] {
+    def depth = 0
+  }
+
+  implicit def unwrapFunc[R <: List, T, U, Res <: List, T2 <: T](implicit inner: Consumer[R, U, Res]) = {
+    val newDepth = inner.depth + 1
+    val isUnit = inner.isUnitCall
+    new Consumer[R**T2, Func[T, U], Res] {
+      def isUnitCall = isUnit
+      def depth = newDepth
+    }
+  }
+  implicit def unwrapRes[R <: List, T: NoUnit] = 
+    new ResConsumer[R, Res[T], R**T](false)
+  implicit def unwrapResUnit[R <: List, T: IsUnit] = 
+    new ResConsumer[R, Res[T], R](true)
+  
+  //def consume[R <: List, T, U, Res <: List, X](f: F[R], func: Func[T, U])(implicit cons: Consumer[R, Func[T, U], Res]): F[Res] = null
+  //implicit def consumed[R <: List, X, Res <: List](func: Method[X])(implicit cons: Consumer[R, X, Res]): F[R] => F[Res] = null
+
+  val someStack: F[Nil**Double**Int] = null
+  val ifunc: Method[Func[Int, Res[String]]] = null
+  //val res: F[Nil**Double**String] = someStack ~! ifunc
+
+  val stringStack: F[Nil**String] = null
+  val any2int: Method[Func[AnyRef, Res[Int]]] = null
+  //val res2: F[Nil**Int] = stringStack.~!(any2int)(unwrapFunc(unwrapRes))
+  //val difunc: Func[Int, Func[Double, Res[String]]] = null
+  //val res1 = consume(someStack, ifunc)
+  //val res2 = consume(someStack, difunc)
+
+  /*trait FuncCreator[F, Res]
+  implicit def func1[T, U]: FuncCreator[T => U, Func[T, Res[U]]] = null
+  implicit def func2[T1, T2, U]: FuncCreator[(T1, T2) => U, Func[T2, Func[T1, Res[U]]]] = null
+
+  implicit def func[X, Y](x: X)(implicit creator: FuncCreator[X, Y]): Y = null.asInstanceOf[Y]
   
-  def method2[T1,T2,U](code:scala.reflect.Code[(T1,T2)=>U]):Method2[T1,T2,U] = 
-    new MethodHandle(CodeTools.methodFromCode(code)) with Method2[T1,T2,U]
+  //def func[T, U](x: X): Func[T, U] = null
+  val myfunc = func((a: Double, b: Int) => "test")
+  //val myfunc = (b: Int) => "wurst"
+  val res3 = consume(someStack, myfunc)*/
   
   object Instructions {
     def withLocal[T,ST<:List,ST2<:List](code:Local[T]=>F[ST]=>F[ST2]):F[ST**T]=>F[ST2] = 
@@ -314,12 +389,12 @@ object Bytecode{
               withLocal( iterator =>
                   tailRecursive[R**U,R**U]( self =>
                     _ ~
-	                  iterator.load ~
-	                  method1((_:java.util.Iterator[T]).hasNext).invoke() ~
+	                  iterator.load ~!
+	                  method1((_:java.util.Iterator[T]).hasNext) ~ //.invoke() ~
 	                  ifne2(
 	                    _ ~
-	                      iterator.load ~
-	                      method1((_:java.util.Iterator[T]).next).invoke() ~
+	                      iterator.load ~!
+	                      method1((_:java.util.Iterator[T]).next) ~ //.invoke() ~
 	                      checkcast(mf.erasure.asInstanceOf[Class[T]]) ~
 	                      func(iterator) ~
 	                      self
diff --git a/bytecode/src/test/scala/net/virtualvoid/bytecode/BytecodeCompilerSpecs.scala b/bytecode/src/test/scala/net/virtualvoid/bytecode/BytecodeCompilerSpecs.scala
index 71c2fcb..f42464f 100644
--- a/bytecode/src/test/scala/net/virtualvoid/bytecode/BytecodeCompilerSpecs.scala
+++ b/bytecode/src/test/scala/net/virtualvoid/bytecode/BytecodeCompilerSpecs.scala
@@ -2,17 +2,17 @@ package net.virtualvoid.bytecode
 
 import org.specs._
 
-object BytecodeCompilerSpecs extends Specification{
-  def compiledTests(compiler:net.virtualvoid.bytecode.Bytecode.ByteletCompiler){
+object BytecodeCompilerSpecs extends Specification {
+  def compiledTests(compiler:net.virtualvoid.bytecode.Bytecode.ByteletCompiler) {
     import Bytecode._
     import Bytecode.Implicits._
     import Bytecode.Instructions._
     
-    val boxInt:Method1[Int,java.lang.Integer] = method1(Integer.valueOf(_:Int))
-    val unboxInt:Method1[java.lang.Integer,Int] = method1((_:java.lang.Integer).intValue)
+    val boxInt: Method1[Int,java.lang.Integer] = method1(Integer.valueOf(_:Int))
+    val unboxInt: Method1[java.lang.Integer,Int] = method1((_:java.lang.Integer).intValue)
     
-    val boxDouble:Method1[Double,java.lang.Double] = method1(java.lang.Double.valueOf(_:Double))
-    val unboxDouble:Method1[java.lang.Double,Double] = method1((_:java.lang.Double).doubleValue)
+    val boxDouble: Method1[Double,java.lang.Double] = method1(java.lang.Double.valueOf(_:Double))
+    val unboxDouble: Method1[java.lang.Double,Double] = method1((_:java.lang.Double).doubleValue)
     
     val concat = method2((s1:String,s2:String)=> s1.concat(s2))
     
@@ -20,52 +20,52 @@ object BytecodeCompilerSpecs extends Specification{
     val append = method2((_:java.lang.StringBuilder).append(_:CharSequence))
     
     "bipush(20)" in {
-      compiler.compile(classOf[String])(str => _~bipush(20)~boxInt)
+      compiler.compile(classOf[String])(str => _~bipush(20)~!boxInt)
         .apply("Test") must be_==(20)}
     "invokemethod1(_.length)" in {
-      compiler.compile(classOf[String])(str => _~str.load~method1((_:String).length)~boxInt)
+      compiler.compile(classOf[String])(str => _~str.load~!method1((_:String).length)~!boxInt)
         .apply("Test") must be_==(4)}
     "locals + method2" in {
-      compiler.compile(classOf[java.lang.String])(p => _ ~ p.load ~ withLocal{ str => _ ~ str.load ~ str.load ~ concat})
+      compiler.compile(classOf[java.lang.String])(p => _ ~ p.load ~ withLocal{ str => _ ~ str.load ~ str.load ~! concat})
       .apply("Test") must be_==("TestTest")}
     "iadd with operations" in {
       compiler.compile(classOf[java.lang.Integer])( i =>
-        _ ~ i.load ~ unboxInt ~ dup
+        _ ~ i.load ~! unboxInt ~ dup
         ~ iadd
-        ~ boxInt
+        ~! boxInt
       ).apply(12) must be_==(24)
     }
     "iadd" in {
-      compiler.compile(classOf[java.lang.Integer])(i => _~i.load~unboxInt~dup~iadd~bipush(3)~iadd~boxInt)
+      compiler.compile(classOf[java.lang.Integer])(i => _~i.load~!unboxInt~dup~iadd~bipush(3)~iadd~!boxInt)
       .apply(12) must be_==(27)}
     "store(_) int in locals" in {
-      compiler.compile(classOf[java.lang.Integer])(i => _~i.load~unboxInt~dup~withLocal{i=> _ ~ i.load}~iadd~boxInt)
+      compiler.compile(classOf[java.lang.Integer])(i => _~i.load~!unboxInt~dup~withLocal{i=> _ ~ i.load}~iadd~!boxInt)
       .apply(12) must be_==(24)}
     "store(_) double in locals" in {
-      compiler.compile(classOf[java.lang.Double])(i => _~i.load~unboxDouble~withLocal{d=>d.load}~boxDouble)
+      compiler.compile(classOf[java.lang.Double])(i => _~i.load~!unboxDouble~withLocal{d=>d.load}~!boxDouble)
       .apply(12.453) must be_==(12.453)}
     "store(_) double after method2" in {
-      compiler.compile(classOf[java.lang.Double])(i => _~i.load~unboxDouble~ldc("test")~dup~concat~pop~withLocal{d=>d.load}~boxDouble)
+      compiler.compile(classOf[java.lang.Double])(i => _~i.load~!unboxDouble~ldc("test")~dup~!concat~pop~withLocal{d=>d.load}~!boxDouble)
       .apply(12.453) must be_==(12.453)}
     "store Int after double" in {
       import java.lang.{Double => jDouble}
       compiler.compile(classOf[java.lang.Double])(dO => 
         _ ~
-          dO.load ~
+          dO.load ~!
           unboxDouble ~
           withLocal(d =>
             _ ~
               bipush(5) ~
               withLocal(i =>
                 _ ~
-                  d.load ~
+                  d.load ~!
                   boxDouble))
       ).apply(.753) must be_==(.753)
     }
     "store Int after double, replace double by String, access int" in {
       compiler.compile(classOf[java.lang.Double])(dO =>
         _ ~
-          dO.load ~
+          dO.load ~!
           unboxDouble ~
           withLocal(d =>
             _ ~
@@ -76,7 +76,7 @@ object BytecodeCompilerSpecs extends Specification{
                   pop ~ 
                   ldc("test") ~ 
                   withLocal(str => f => f) ~
-                  i.load)) ~
+                  i.load)) ~!
           boxInt
       ).apply(.753) must be_==(5)
     } 
@@ -89,23 +89,23 @@ object BytecodeCompilerSpecs extends Specification{
       .apply(Array("That","is","a","Test")) must be_==("test")
     }
     "save int element to array and load it afterwards" in {
-      compiler.compile(classOf[Array[Int]])(ar=>_~ar.load~dup~bipush(1)~bipush(13)~astore~bipush(1)~aload~dup~iadd~boxInt)
+      compiler.compile(classOf[Array[Int]])(ar=>_~ar.load~dup~bipush(1)~bipush(13)~astore~bipush(1)~aload~dup~iadd~!boxInt)
       .apply(Array(1,2,3,4)) must be_==(26)
     }
     "get array length" in {
-      compiler.compile(classOf[Array[String]])(ar=>_~ar.load~arraylength~boxInt)
+      compiler.compile(classOf[Array[String]])(ar=>_~ar.load~arraylength~!boxInt)
       .apply(Array("That","is","a","problem")) must be_==(4)
     }
     "isub" in {
-      compiler.compile(classOf[java.lang.Integer])(i => _~i.load~unboxInt~bipush(3)~isub~boxInt)
+      compiler.compile(classOf[java.lang.Integer])(i => _~i.load~!unboxInt~bipush(3)~isub~!boxInt)
       .apply(12) must be_==(9)
     }
     "dup_x1" in {
-      compiler.compile(classOf[java.lang.Integer])(i => _~i.load~dup~toString~swap()~unboxInt~dup_x1~swap()~pop~iadd~boxInt)
+      compiler.compile(classOf[java.lang.Integer])(i => _~i.load~dup~!toString~swap()~!unboxInt~dup_x1~swap()~pop~iadd~!boxInt)
       .apply(12) must be_==(24)
     }
     "create new StringBuilder" in {
-      compiler.compile(classOf[java.lang.String])(str => _~str.load~dup~newInstance(classOf[java.lang.StringBuilder])~swap()~append~swap()~append~toString)
+      compiler.compile(classOf[java.lang.String])(str => _~str.load~dup~newInstance(classOf[java.lang.StringBuilder])~swap()~append()~swap()~append()~toString())
       .apply("test") must be_==("testtest") 
     }
     "store(_) string after void method" in {
@@ -113,7 +113,7 @@ object BytecodeCompilerSpecs extends Specification{
         _ ~ 
           str.load ~ 
           newInstance(classOf[java.text.SimpleDateFormat]) ~ 
-          ldc("yyyy") ~ 
+          ldc("yyyy") ~!
           method2((_:java.text.SimpleDateFormat).applyPattern(_:java.lang.String)) ~
           withLocal{str=>str.load})
       .apply("test") must be_==("test")
@@ -121,8 +121,8 @@ object BytecodeCompilerSpecs extends Specification{
     "scala parameterless method call" in {
       compiler.compile(classOf[Option[java.lang.String]])(str =>
         _ ~
-          str.load ~
-          method1((_:Option[java.lang.String]).isDefined) ~
+          str.load ~!
+          method1((_:Option[java.lang.String]).isDefined) ~!
           method1(java.lang.Boolean.valueOf(_:Boolean))
       )
       .apply(Some("x")) must be_==(true)
@@ -130,8 +130,8 @@ object BytecodeCompilerSpecs extends Specification{
     "method call to superclass method" in {
       compiler.compile(classOf[java.lang.StringBuilder])( sb =>
         _ ~
-          sb.load ~
-          method1((_:java.lang.StringBuilder).length) ~
+          sb.load ~!
+          method1((_:java.lang.StringBuilder).length) ~!
           boxInt
       )
       .apply(new java.lang.StringBuilder) must be_==(0)
@@ -142,7 +142,7 @@ object BytecodeCompilerSpecs extends Specification{
       compiler.compile(classOf[java.lang.StringBuilder])( sb =>
         _ ~
           sb.load ~
-          dup ~
+          dup ~!
           append // accepts CharSequence
       )
       .apply(sb).toString must be_==("testtest")
@@ -153,7 +153,7 @@ object BytecodeCompilerSpecs extends Specification{
         _ ~
           sb.load ~
           pop ~
-          getstatic(() => StaticVariableContainer.x) ~
+          getstatic(() => StaticVariableContainer.x) ~!
           boxInt
       )
       .apply(null) must be_==(3263)
@@ -166,7 +166,7 @@ object BytecodeCompilerSpecs extends Specification{
           bipush(38) ~
           putstatic(StaticVariableContainer.x = _) ~
           pop ~
-          getstatic(() => StaticVariableContainer.x) ~
+          getstatic(() => StaticVariableContainer.x) ~!
           boxInt
       )
       .apply(null) must be_==(38)
@@ -175,7 +175,7 @@ object BytecodeCompilerSpecs extends Specification{
       val f:java.lang.Integer => String = 
       compiler.compile(classOf[java.lang.Integer],classOf[String])(input => ret =>
         _ ~
-          input.load ~
+          input.load ~!
           unboxInt ~
           ifne(_ ~ ldc(">0") ~ ret.jmp) ~ ldc("==0") ~ ret.jmp
       )
@@ -185,7 +185,7 @@ object BytecodeCompilerSpecs extends Specification{
     "ifeq2" in {
       val f = compiler.compile(classOf[java.lang.Integer])( i => 
         _ ~ 
-          i.load ~
+          i.load ~!
           unboxInt ~
           bipush(5) ~
           isub ~
@@ -202,7 +202,7 @@ object BytecodeCompilerSpecs extends Specification{
     "ifne2" in {
       val f = compiler.compile(classOf[java.lang.Integer])( i =>
         _ ~ 
-          i.load ~
+          i.load ~!
           unboxInt ~
           bipush(5) ~
           isub ~
@@ -220,7 +220,7 @@ object BytecodeCompilerSpecs extends Specification{
       val f = compiler.compile(classOf[Array[Int]])( array =>
         _ ~
           bipush(0) ~
-          RichOperations.foldArray(array)(index => iadd) ~
+          RichOperations.foldArray(array)(index => iadd) ~!
           boxInt
       )
       f(Array(1,2,3,4)) must be_==(10)
@@ -231,7 +231,7 @@ object BytecodeCompilerSpecs extends Specification{
         _ ~
           it.load ~
           newInstance(classOf[java.lang.StringBuilder]) ~
-          RichOperations.foldIterator(it => _ ~ append) ~
+          RichOperations.foldIterator(it => _ ~! append) ~!
           toString
       )
       f(java.util.Arrays.asList("a","b","c").iterator) must be_==("abc")
@@ -243,9 +243,9 @@ object BytecodeCompilerSpecs extends Specification{
             dup ~
             ifnull(
               _ ~ pop ~ ldc("isnull")
-             ,_ ~ 
+             ,_ ~! 
                 toString ~
-               	ldc(" isnotnull") ~
+               	ldc(" isnotnull") ~!
                 concat)
       )
       f(null) must be_==("isnull")
@@ -257,9 +257,9 @@ object BytecodeCompilerSpecs extends Specification{
             o.load ~
             dup ~
             ifnonnull(
-             _ ~ 
+             _ ~! 
                 toString ~
-               	ldc(" isnotnull") ~
+               	ldc(" isnotnull") ~!
                 concat,
              _ ~ pop ~ ldc("isnull"))
       )
@@ -270,7 +270,7 @@ object BytecodeCompilerSpecs extends Specification{
       compiler.compile(classOf[String],classOf[String],classOf[String])((str1,str2) => ret =>
         _ ~
           str1.load ~
-          str2.load ~
+          str2.load ~!
           concat ~
           ret.jmp
       )("String1","String2") must be_==("String1String2")
@@ -280,8 +280,8 @@ object BytecodeCompilerSpecs extends Specification{
       val intValue = dynMethod[jInt,Int](classOf[jInt].getMethod("intValue"))
       compiler.compile(classOf[jInt])(i =>
         _ ~
-          i.load ~
-          intValue ~
+          i.load ~!
+          intValue ~!
           method1(jInt.toString(_:Int))
       ).apply(5) must be_==("5")
     }
@@ -290,19 +290,21 @@ object BytecodeCompilerSpecs extends Specification{
       compiler.compile(classOf[String])(str =>
         _ ~
           str.load ~
-          dup ~
+          dup ~!
           intValue
       ).apply("Test") must be_==("TestTest")
-    } 
+    }
   }
   
-  "Compiler" should {
-    "succeed in generic Tests" in compiledTests(net.virtualvoid.bytecode.ASMCompiler)
-  }
+  
   "Interpreter" should {
-    "succeed in generic Tests" in compiledTests(net.virtualvoid.bytecode.Interpreter)
+    "execute correctly" in compiledTests(net.virtualvoid.bytecode.Interpreter)
   }
-  "Dynamic method type checking" should {
+  "Compiler" should {
+    "execute correctly" in compiledTests(net.virtualvoid.bytecode.ASMCompiler)
+  }
+  
+  "Dynamic method type checking" in {
     import Bytecode.dynMethod
     "work with static methods" in {
       dynMethod[Int,java.lang.Integer](classOf[Integer].getMethod("valueOf",classOf[Int])).method.getName must be_==("valueOf")
diff --git a/bytecode/src/test/scala/net/virtualvoid/bytecode/BytecodeStaticSpecs.scala b/bytecode/src/test/scala/net/virtualvoid/bytecode/BytecodeStaticSpecs.scala
index cdefbbd..370dd5a 100644
--- a/bytecode/src/test/scala/net/virtualvoid/bytecode/BytecodeStaticSpecs.scala
+++ b/bytecode/src/test/scala/net/virtualvoid/bytecode/BytecodeStaticSpecs.scala
@@ -149,7 +149,7 @@ object BytecodeStaticSpecs extends Specification {
     "dup on String" in {Stack("Nil**String") must haveOp("dup")}
 
     "invoke unit method" in {
-      Stack("Nil**java.lang.StringBuffer**Int") must haveOp("method2((_: java.lang.StringBuffer).setLength((_: Int)))")
+      Stack("Nil**java.lang.StringBuffer**Int") must haveOp("method2((_: java.lang.StringBuffer).setLength((_: Int)))()")
     }
   }
