Bottom: ed45206f813d06ffff597c85b003553bfd7da149
Top:    068c92faa9f6eee33c93b71a1c685e936da65411
Author: Johannes Rudolph <johannes_rudolph@gmx.de>
Date:   2010-01-10 12:14:16 +0100

not working crap


---

diff --git a/objectformatter/.scala_dependencies b/objectformatter/.scala_dependencies
new file mode 100644
index 0000000..138a3b8
--- /dev/null
+++ b/objectformatter/.scala_dependencies
@@ -0,0 +1,3 @@
+/home/johannes/git/self/bytecode/objectformatter/target/test-classes:/home/johannes/git/self/bytecode/objectformatter/target/classes:/home/johannes/.m2/repository/asm/asm/3.1/asm-3.1.jar:/home/johannes/.m2/repository/net/virtualvoid/bytecode/bytecode/2.1-SNAPSHOT/bytecode-2.1-SNAPSHOT.jar:/home/johannes/.m2/repository/org/hamcrest/hamcrest-core/1.1/hamcrest-core-1.1.jar:/home/johannes/.m2/repository/org/hamcrest/hamcrest-library/1.1/hamcrest-library-1.1.jar:/home/johannes/.m2/repository/org/jmock/jmock/2.4.0/jmock-2.4.0.jar:/home/johannes/.m2/repository/junit/junit/4.4/junit-4.4.jar:/home/johannes/.m2/repository/org/scala-lang/scala-compiler/2.7.5/scala-compiler-2.7.5.jar:/home/johannes/.m2/repository/org/scala-lang/scala-library/2.7.5/scala-library-2.7.5.jar:/home/johannes/.m2/repository/org/scalacheck/scalacheck/1.3/scalacheck-1.3.jar:/home/johannes/.m2/repository/org/scalatest/scalatest/0.9.3/junit-4.1.jar:/home/johannes/.m2/repository/org/scalatest/scalatest/0.9.3/scalatest-0.9.3.jar:/home/johannes/.m2/repository/org/specs/specs/1.3.1/specs-1.3.1.jar:/home/johannes/opt/eclipse-3.5/configuration/org.eclipse.osgi/bundles/540/1/.cp/lib/scala-library.jar:/home/johannes/opt/eclipse-3.5/configuration/org.eclipse.osgi/bundles/540/1/.cp/lib/scala-dbc.jar:/home/johannes/opt/eclipse-3.5/configuration/org.eclipse.osgi/bundles/540/1/.cp/lib/scala-swing.jar:/usr/lib/jvm/java-6-openjdk/jre/lib/resources.jar:/usr/lib/jvm/java-6-openjdk/jre/lib/rt.jar:/usr/lib/jvm/java-6-openjdk/jre/lib/jsse.jar:/usr/lib/jvm/java-6-openjdk/jre/lib/jce.jar:/usr/lib/jvm/java-6-openjdk/jre/lib/charsets.jar:/usr/lib/jvm/java-6-openjdk/jre/lib/rhino.jar:/usr/lib/jvm/java-6-openjdk/jre/lib/ext/dnsns.jar:/usr/lib/jvm/java-6-openjdk/jre/lib/ext/sunpkcs11.jar:/usr/lib/jvm/java-6-openjdk/jre/lib/ext/sunjce_provider.jar:/usr/lib/jvm/java-6-openjdk/jre/lib/ext/localedata.jar:/usr/lib/jvm/java-6-openjdk/jre/lib/ext/gnome-java-bridge.jar:/usr/lib/jvm/java-6-openjdk/jre/lib/ext/pulse-java.jar
+-------
+-------
diff --git a/objectformatter/src/main/scala/net/virtualvoid/string/ESParser.scala b/objectformatter/src/main/scala/net/virtualvoid/string/ESParser.scala
index f396b3c..c1e8541 100644
--- a/objectformatter/src/main/scala/net/virtualvoid/string/ESParser.scala
+++ b/objectformatter/src/main/scala/net/virtualvoid/string/ESParser.scala
@@ -7,8 +7,8 @@ import scala.util.parsing.combinator.syntactical._
 import scala.util.parsing.syntax._
 
 object Java{
-  implicit def it2it[T](it:java.lang.Iterable[T]):Iterable[T] = new Iterable[T]{
-    def elements = new Iterator[T]{
+  implicit def it2it[T](it:java.lang.Iterable[T]):Iterable[T] = new Iterable[T] {
+    def iterator = new Iterator[T] {
       val innerIt = it.iterator
       def hasNext = innerIt.hasNext
       def next = innerIt.next
diff --git a/objectformatter/src/main/scala/net/virtualvoid/string/EnhancedStringsPlugin.scala b/objectformatter/src/main/scala/net/virtualvoid/string/EnhancedStringsPlugin.scala
index d54e96c..f002af2 100644
--- a/objectformatter/src/main/scala/net/virtualvoid/string/EnhancedStringsPlugin.scala
+++ b/objectformatter/src/main/scala/net/virtualvoid/string/EnhancedStringsPlugin.scala
@@ -20,7 +20,7 @@ class EnhancedStringsPlugin(val global: Global) extends Plugin {
 	   import global.definitions._
 
 	   val global = EnhancedStringsPlugin.this.global
-	   val runsAfter = "typer"
+	   override val runsAfter = List("typer")
 	  /** The phase name of the compiler plugin
 	   *  @todo Adapt to specific plugin.
 	   */
@@ -79,6 +79,7 @@ class EnhancedStringsPlugin(val global: Global) extends Plugin {
 	          //localTyper.typed(atPos(tree.pos){compile(EnhancedStringFormatParser.parse(str))})
 	        } catch {
 	          case p:ParseException => error(p.getMessage);tree
+	          case e:TypeError => error(e.getMessage);tree
 	        }
 	      case _ => tree
 	    }
diff --git a/objectformatter/src/main/scala/net/virtualvoid/string/FormatCompiler.scala b/objectformatter/src/main/scala/net/virtualvoid/string/FormatCompiler.scala
deleted file mode 100644
index 25d56d6..0000000
--- a/objectformatter/src/main/scala/net/virtualvoid/string/FormatCompiler.scala
+++ /dev/null
@@ -1,206 +0,0 @@
-package net.virtualvoid.string
-
-import java.lang.{StringBuilder,String=>jString}
-
-object Compiler{
-  import net.virtualvoid.bytecode.Bytecode
-  import net.virtualvoid.bytecode.ASMCompiler
-  import Bytecode._
-  import Bytecode.Instructions._
-  import Bytecode.Implicits._
-
-  val parser = EnhancedStringFormatParser
-  import AST._
-  
-  def elementType(it:java.lang.reflect.Type,of:Class[_])
-  	:Class[_ <: AnyRef] = {
-    TypeHelper.genericInstanceType(it,of,Array()) match{
-      case Some(cl:java.lang.Class[AnyRef]) => cl
-      case _ => throw new java.lang.Error("Can't get element type of "+it)
-    }
-  }
-
-  def compileGetExp[R<:List,LR<:List,T,Ret](exp:Exp
-                                            ,cl:Class[T]
-                                            ,retType:Class[Ret])
-                                           (f:F[R**T]):F[R**Ret] = 
-  exp match {
-    case p@ParentExp(inner,parent) =>{
-      val m = p.method(cl)
-      f ~ invokemethod1Dyn(m,classOf[AnyRef]) ~ 
-       compileGetExp(inner,m.getReturnType.asInstanceOf[Class[Object]],retType)
-    }
-    case ThisExp =>
-      f ~ checkcast(retType) // TODO: don't know why we need this, examine it
-    case e:Exp => {
-      f ~ invokemethod1Dyn(e.method(cl),retType)
-    }
-  }
-    
-  def compileFormatElementList[R<:List,LR<:List,T<:java.lang.Object]
-                 (elements:FormatElementList,cl:Class[T],value:Local[T])
-                 (f:F[R**StringBuilder]):F[R**StringBuilder] =
-    elements.elements.foldLeft(f){(frame,element) => 
-      compileElement(element,cl,value)(frame)}
-
-  def id[X]:X=>X = x=>x
-  
-  def compileElement[R<:List,LR<:List,T<:java.lang.Object]
-                     (ele:FormatElement,cl:Class[T],value:Local[T])
-                     (f:F[R**StringBuilder])
-                     :F[R**StringBuilder]
-    = ele match {
-      case Literal(str) => 
-        f ~ ldc(str) ~ invokemethod2(_.append(_))
-      case ToStringConversion(e) =>
-        f ~ value.load ~
-          compileGetExp(e,cl,classOf[AnyRef]) ~ 
-          invokemethod1(_.toString) ~ 
-          invokemethod2(_.append(_))
-      case Expand(exp,sep,inner) => {
-        import Bytecode.RichOperations.foldIterator
-          
-        val retType = exp.returnType(cl)
-
-        if (classOf[java.lang.Iterable[_]].isAssignableFrom(retType)){
-          val eleType:Class[AnyRef] = elementType(exp.genericReturnType(cl)
-                                                  ,classOf[java.lang.Iterable[_]])
-                                                  .asInstanceOf[Class[AnyRef]]
-          
-          f ~
-            value.load ~
-            compileGetExp(exp,cl,classOf[java.lang.Iterable[AnyRef]]) ~
-            invokemethod1(_.iterator) ~
-            swap ~
-            foldIterator[R,AnyRef,StringBuilder](
-              it => 
-              	_ ~ withLocal(innerValue => compileFormatElementList(inner,eleType,innerValue)) ~
-              	  it.load ~
-              	  invokemethod1(_.hasNext) ~
-              	  ifne2(
-              	  	_ ~
-              	  	  ldc(sep) ~
-              	  	  invokemethod2(_.append(_))
-                    ,f=>f
-              	  )
-            )(scala.reflect.Manifest.classType(eleType))
-        }
-        else if (retType.isArray){
-          val eleType:Class[AnyRef] = retType.getComponentType.asInstanceOf[Class[AnyRef]]
-
-          if (eleType.isPrimitive)
-            throw new java.lang.Error("can't handle primitive arrays right now");
-
-          import Bytecode.RichOperations.foldArray
-          
-          f ~
-            value.load ~
-            compileGetExp(exp,cl,retType.asInstanceOf[Class[Array[AnyRef]]]) ~
-            dup ~
-            arraylength ~
-            bipush(1) ~
-            isub ~
-            withLocal(lastIndex =>
-              _ ~
-	            swap ~
-	            foldArray(index =>
-	              _ ~ withLocal(innerValue => compileFormatElementList(inner,eleType,innerValue)) ~
-                    lastIndex.load ~
-                    index.load ~
-                    isub ~
-                    ifne2(
-                      _ ~
-                        ldc(sep) ~
-                        invokemethod2(_.append(_))
-                      , f=>f
-                    )
-	            )
-            )
-        }
-        else
-          throw new java.lang.Error("can only iterate over "+
-                                      "iterables and arrays right now")
-      }
-      case Conditional(inner,thens,elses) => {
-        val retType = inner.returnType(cl)
-
-        if (retType == java.lang.Boolean.TYPE || 
-              classOf[java.lang.Boolean].isAssignableFrom(retType)){
-          f ~ 
-            value.load ~
-            (if (retType == java.lang.Boolean.TYPE)
-               compileGetExp(inner,cl,classOf[Boolean])
-             else 
-               compileGetExp(inner,cl,classOf[java.lang.Boolean]) _ 
-             ~ invokemethod1(_.booleanValue)
-            ) ~
-            ifeq2(
-              compileFormatElementList(elses,cl,value),
-              compileFormatElementList(thens,cl,value))
-        }
-        else if (classOf[Option[AnyRef]].isAssignableFrom(retType)){
-          val eleType = elementType(inner.genericReturnType(cl)
-                                    ,classOf[Option[_]])
-            .asInstanceOf[Class[AnyRef]]
-          f ~
-            value.load ~
-            compileGetExp(inner,cl,classOf[Option[AnyRef]]) ~
-            dup ~
-            invokemethod1(_.isDefined) ~
-            ifeq2(
-              _ ~ pop ~ compileFormatElementList(elses,cl,value),
-              _ ~ 
-                checkcast(classOf[Some[AnyRef]]) ~
-                invokemethod1(_.get) ~
-                withLocal(newValue => compileFormatElementList(thens,eleType,newValue)))
-        }
-        else
-          throw new Error("can't use "+retType+" in a conditional")
-      }
-      case DateConversion(exp,format) => {
-        val retType = exp.returnType(cl)
-        
-        val DateClass:Class[java.util.Date] = classOf[java.util.Date]
-        val CalendarClass:Class[java.util.Calendar] = classOf[java.util.Calendar]
-        
-        f ~ newInstance(classOf[java.text.SimpleDateFormat]) ~
-          dup ~
-          ldc(format) ~ 
-          invokemethod2(_.applyPattern(_)) ~ pop_unit ~
-          value.load ~
-          (f => 
-            retType match {
-              case x if DateClass.isAssignableFrom(x)     => 
-                f ~ compileGetExp(exp,cl,DateClass)
-              case x if CalendarClass.isAssignableFrom(x) => 
-                f ~                
-                  compileGetExp(exp,cl,CalendarClass) ~ 
-                  invokemethod1(_.getTime)
-              case _ => throw new java.lang.Error(
-                "Expected date- or calendar- typed property. "+
-                cl+" can't be converted.") 
-            }
-          ) ~
-          invokemethod2(_.format(_)) ~
-          invokemethod2(_.append(_))
-      }
-    }
-  def compile[T<:AnyRef](format:String,cl:Class[T]):T=>jString = {
-    val elements:FormatElementList = parser.parse(format)
-    ASMCompiler.compile(cl)(
-      _ 
-      ~ withLocal(value =>
-      	_ ~ newInstance(classOf[StringBuilder])
-      	  ~ compileFormatElementList(elements,cl,value))
-      ~ invokemethod1(_.toString)
-     )
-  }
-}
-
-object FormatCompiler extends IObjectFormatterFactory{
-  def formatter[T<:AnyRef](clazz:Class[T],fmt:String) = 
-	  new IObjectFormatter[T]{
-	  	val compiler = Compiler.compile[T](fmt,clazz)
-	  	def format(o:T):String = compiler(o)
-  	  }
-}
\ No newline at end of file
diff --git a/objectformatter/src/test/scala/net/virtualvoid/string/Benchmark.scala b/objectformatter/src/test/scala/net/virtualvoid/string/Benchmark.scala
deleted file mode 100644
index e344a90..0000000
--- a/objectformatter/src/test/scala/net/virtualvoid/string/Benchmark.scala
+++ /dev/null
@@ -1,96 +0,0 @@
-package net.virtualvoid.string
-
-object Benchmark {
-  class Test{
-    val string = "This is a Test"
-    val chars = string.toCharArray.map(Character.valueOf(_))
-    
-    def characters = chars
-    def option = Some("test")
-  }
-  
-  val formats = List(
-    ("simple literal","abcdefghijklmnopqrstuvwxyz"),
-    ("method access","String characters: #characters"),
-    ("array expansion","Characters: #characters[#this]{,}*"),
-    ("option array","Option: #option?[Yes: #this|No]")
-  )
-  
-  val sampleObject = new Test
-  
-  val formatFactories = List(ObjectFormatter,FormatCompiler)
-  
-  def benchmark(times:Int,formatter:IObjectFormatter[Test]) = {
-        System.out.println("run")
-    val startTime = System.nanoTime
- 
-	var i = times
-	do{
-	  formatter.format(sampleObject)
-	  i = i - 1;
-	}while(i>0)
-   
-	System.nanoTime - startTime
-  }
-  
-  def benchmarkWithCompilation(times:Int,factory:IObjectFormatterFactory,format:String) = {
-	val startTime = System.nanoTime
- 
-	val formatter = factory.formatter(classOf[Test],format)
-	
-	var i = times
-	do{
-	  formatter.format(sampleObject)
-	  i = i - 1;
-	}while(i>0)
-   
-	System.nanoTime - startTime
-  }
-  
-  def main(args:Array[String]){
-	val times = args(0).toInt
-	val warmup = args(1) == "w"
-	val withCompileTimes = args(1) == "c"
- 
-	val averageOf = 20
-	
-	for((formatName,format)  <- formats;
-	  	factory <- formatFactories)
-	  if (withCompileTimes) 
-		  System.out.println(factory.getClass.getSimpleName+":"+formatName+" "+(benchmarkWithCompilation(times,factory,format)/1e6)+" ms")
-	  else {
-		  val formatter = factory.formatter(classOf[Test],format)
-
-		  val name = factory.getClass.getSimpleName+":"+formatName
-		  
-		  System.out.println(" + Warming up for "+name)
-		  if (warmup)
-			  benchmark(times*10,formatter)
-		  System.out.println(" - Warming up finished for "+name)
-		  
-		  System.out.println(" + Running "+name)
-
-	      val results:Array[Long] = (0 until averageOf).map(i => benchmark(times,formatter)).toArray
-		  System.out.println(" - Finished running "+name)
-		  //for(res <- results) System.out.println(res/1e6)
-       
-		  val avg = results.foldLeft(0.)(_+_.toDouble)/averageOf
-		  val variance = results.foldLeft(0d)((sum,x)=> sum + (x-avg)*(x-avg))/(averageOf-1.)
-		  val stdev = Math.pow(variance,.5)
-		  
-		  def ind(x:long) = (x-avg) match{
-		    case s if s <= -2*stdev => '↡'
-		    case s if s <= -stdev   => '↓'
-		    case s if s <= -stdev/2.=> '↘'
-		    case s if s <= stdev/2  => '→'
-		    case s if s <= stdev    => '↗'
-		    case s if s <= 2*stdev  => '↑'
-		    case _	                => '↟'
-		  }
-    
-		  val indicators:CharSequence = results.map(ind(_))
-		  
-	      System.out.println(name+" Average of "+averageOf+" runs: "+avg/1e6+" ms +/- "+stdev/1e6+" ms = "+stdev*100./avg+"%"+"\n["+indicators+"]")
-	  }
-  }
-}
diff --git a/objectformatter/src/test/scala/net/virtualvoid/string/ESParserSpecs.scala b/objectformatter/src/test/scala/net/virtualvoid/string/ESParserSpecs.scala
deleted file mode 100644
index 82f4675..0000000
--- a/objectformatter/src/test/scala/net/virtualvoid/string/ESParserSpecs.scala
+++ /dev/null
@@ -1,70 +0,0 @@
-package net.virtualvoid.string
-
-import _root_.org.specs._
-
-object ParserSpecs extends Specification {
-  import EnhancedStringFormatParser.parse
-  import AST._
-
-  "The parser" should parseCorrectly {
-    "'test'" in {"test" must beParsedAs(Literal("test"))}
-    "'#prop'" in {"#prop" must beParsedAs(Exp("prop"))}
-    "'#{prop}'" in {"#{prop}" must beParsedAs(Exp("prop"))}
-    "'#{prop.member}'" in {"#{prop.member}" must beParsedAs(ParentExp(Exp("member"),"prop"))}
-    "'#prop.member'" in {"#prop.member" must beParsedAs(ParentExp(Exp("member"),"prop"))}
-    "'#listProp*'" in {"#listProp*" must beParsedAs(expand(Exp("listProp"),"",ToStringConversion(ThisExp)))}
-    "'#listProp{,}*'" in {"#listProp{,}*" must beParsedAs(expand(Exp("listProp"),",",ToStringConversion(ThisExp)))}
-    "'#{listProp}{,}*'" in {"#{listProp}{,}*" must beParsedAs(expand(Exp("listProp"),",",ToStringConversion(ThisExp)))}
-    "'#listProp[test]{,}*'" in {"#listProp[test]{,}*" must beParsedAs(expand(Exp("listProp"),",",Literal("test")))}
-
-    "#this" in {"#this" must beParsedAs(ThisExp)}
-    "#{this}" in {"#{this}" must beParsedAs(ThisExp)}
-    "#this[]*" in {"#this[]*" must beParsedAs(expand(ThisExp,""))}
-
-    //escaped square brackets
-    "#[abc#]" in {"#[abc#]" must beParsedAs(Literal("[abc]"))}
-
-    //escaped hash
-    "##abc" in {"##abc" must beParsedAs(Literal("#abc"))}
-
-    // more complex escape situations
-    "###] ####blub ###[" in {"###] ####blub ###[" must beParsedAs(Literal("#] ##blub #["))}
-
-    // test weird control combinations
-    "Dots in normal literals 'This is a sentence.'" in {"This is a sentence." must beParsedAs(Literal("This is a sentence."))}
-    "Dots after curly braced expressions 'This is a #{exp}.'" in {"This is a #{exp}." must beParsedAs(Literal("This is a "),ToStringConversion(Exp("exp")),Literal("."))}
-
-    "Curly Braces somewhere in between 'This is {braced}'" in {"This is {braced}" must beParsedAs(Literal("This is {braced}"))}
-    "question mark after expression" in {"Who lives at #address?" must beParsedAs(Literal("Who lives at "),ToStringConversion(Exp("address")),Literal("?"))}
-    
-    // conversions
-    "date conversion" in {"#this->date[dd.MM.yyyy]" must beParsedAs(DateConversion(ThisExp,"dd.MM.yyyy"))}
-    
-    // conditionals
-    "conditionals" in {"#this?[#this|Nope]" must beParsedAs(Conditional(ThisExp,toks(ToStringConversion(ThisExp)),toks(Literal("Nope"))))}
-    "complex conditionals" in {"#{x.getClass.getMethods}?[#it|None]" must beParsedAs(Conditional(
-      ParentExp(ParentExp(Exp("getMethods"),"getClass"),"x")
-      ,toks(ToStringConversion(Exp("it"))),toks(Literal("None"))))}
-    "conditional and expansion" in {"#x[#it?[#it|Leer]]{,}*" must beParsedAs(Expand(Exp("x"),",",toks(Conditional(Exp("it"),toks(ToStringConversion(Exp("it"))),toks(Literal("Leer"))))))}
-  }
-
-  // helper methods
-
-  import org.specs.matcher.Matcher
-  def beParsedAs(ts:FormatElement*) = new Matcher[String]{
-    val tokens = toks(ts:_*)
-    def apply(str: => String) = {
-      val l = parse(str)
-      (l.toString == tokens.toString,"equal",l.toString + " is not equal to the expected " + tokens.toString)
-    }
-  }
-  def beParsedAs(ts:Exp):Matcher[String] = beParsedAs(ToStringConversion(ts))
-  
-  def expand(e:Exp,sep:String,inner:FormatElement*) = Expand(e,sep,toks(inner:_*))
-  def toks(inner:FormatElement*) = FormatElementList(List(inner:_*))
-
-  import org.specs.specification.Example
-  def parseCorrectly(e: =>Example) = { currentSut.verb += " parse correctly"; e }
-}
-
-class ParserSpecsTest extends runner.JUnit4(ParserSpecs)
\ No newline at end of file
diff --git a/objectformatter/src/test/scala/net/virtualvoid/string/EvaluateSpecs.scala b/objectformatter/src/test/scala/net/virtualvoid/string/EvaluateSpecs.scala
deleted file mode 100644
index f49d047..0000000
--- a/objectformatter/src/test/scala/net/virtualvoid/string/EvaluateSpecs.scala
+++ /dev/null
@@ -1,77 +0,0 @@
-package net.virtualvoid.string
-
-import _root_.org.specs._
-
-object EvaluateSpecs extends Specification{
-  import java.lang.{String=>jString}
-  case class Bank(n:String){
-    def name():jString = n
-  }
-  import java.util.GregorianCalendar
-  import java.util.Calendar._
-  case class Transaction(date:GregorianCalendar,centAmount:Int){
-    def isWithdrawal() = centAmount < 0
-    def amount():java.lang.Integer = Math.abs(centAmount) // no primitives for now
-  }
-  case class Account(n:String,b:Bank) {
-    def number():jString = n
-    def bank() = b
-    def transactions():Array[Transaction] = Array(Transaction(new GregorianCalendar(2008,OCTOBER,1),5),Transaction(new GregorianCalendar(2008,OCTOBER,3),-4))
-  }
-  class Person{
-      def name():java.lang.String = "Joe"
-      def accountNames():java.util.List[java.lang.String] = java.util.Arrays.asList("a","b")
-      val sparkasse = Bank("Sparkasse")
-      def accounts():java.util.List[Account] = java.util.Arrays.asList(Account("78910",sparkasse),Account("12345",Bank("Volksbank")))
-      def accs():Array[Account] = accounts().toArray(new Array[Account](0))
-      def noAddress:Option[String] = None
-      def address:Option[String] = Some("Some Street 5")
-  }
-  val thePerson = new Person
-
-  def evaluate(factory:IObjectFormatterFactory){
-    import matcher.Matcher
-    def evaluateObjectAs(obj:AnyRef,str:String) = new Matcher[String]{
-      def apply(format: =>String) = {
-        val res = factory.format(format,obj)
-        (res == str,"evaluates as "+str,"does not evaluate as "+str+" but as "+ res)
-      }
-    }
-    def evaluateAs(str:String) = evaluateObjectAs(thePerson,str)
-
-    "literal" in {"literal" must evaluateAs("literal")}
-    "property access" in {"#name" must evaluateAs(thePerson.name)}
-    "string array access" in {"#accountNames*" must evaluateAs("ab")}
-    "string array access with separator" in {"#accountNames{,}*" must evaluateAs("a,b")}
-    "object iterable access with inner expression" in {"#accounts[#number]{,}*" must evaluateAs("78910,12345")}
-    "object array access with inner expression" in {"#accs[#number]{,}*" must evaluateAs("78910,12345")}
-    "deep property access" in {"#accs[#bank.name]{,}*" must evaluateAs("Sparkasse,Volksbank")}
-    "format dates properly" in {"#this->date[dd.MM.yyyy]" must evaluateObjectAs(new GregorianCalendar(2008,OCTOBER,1),"01.10.2008")}
-    "evaluate conditionals true" in {"#this?[yes|no]" must evaluateObjectAs(java.lang.Boolean.valueOf(true),"yes")}
-    "evaluate conditionals false" in {"#this?[yes|no]" must evaluateObjectAs(java.lang.Boolean.valueOf(false),"no")}
-    "evaluate conditionals with Some" in {"#address?[Found: #this|no address given]" must evaluateAs("Found: Some Street 5")}
-    "evaluate conditionals with None" in {"#noAddress?[Found: #this|no address given]" must evaluateAs("no address given")}
-  }
-
-  "The format interpreter" should {
-    evaluate(ObjectFormatter)
-  }
-  "The format compiler" should {
-    evaluate(FormatCompiler)
-  }
-}
-
-object FormatAccountsExample{
-  def main(args:Array[String]){
-    System.out.println("Hello")
-    System.out.println(FormatCompiler.format(
-"""#name has these bank accounts:
-  #accs[#number at #bank.name having these transactions:
-    #transactions[#isWithdrawal?[Withdrawal|Deposit]: #amount Euros at #date->date[dd.MM.yyyy]]{ 
-    }*]{
-  }*
-""",EvaluateSpecs.thePerson))
-  }
-}
-
-class EvaluateSpecsTest extends runner.JUnit4(EvaluateSpecs)
diff --git a/objectformatter/with-plugin.sh b/objectformatter/with-plugin.sh
index fcc6cf6..f0e496a 100755
--- a/objectformatter/with-plugin.sh
+++ b/objectformatter/with-plugin.sh
@@ -1 +1 @@
-scala -Xplugin:target/objectformatter-1.0-SNAPSHOT.jar
+~/downloads/sources/scala-2.8.0.r19928-b20091129020233/bin/scala -Xplugin:target/objectformatter-1.0-SNAPSHOT.jar
