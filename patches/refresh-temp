Bottom: 973fa5c06552192ab85caeed3f06efd3fcff42e2
Top:    00f03d9a4a22416c38501fa27623a8d886eaaff5
Author: Johannes Rudolph <johannes_rudolph@gmx.de>
Date:   2009-10-06 21:02:03 +0200

Refresh of typed

---

diff --git a/objectformatter/src/main/scala/net/virtualvoid/string/FormatCompiler.scala b/objectformatter/src/main/scala/net/virtualvoid/string/FormatCompiler.scala
index cca4b11..90e58f1 100644
--- a/objectformatter/src/main/scala/net/virtualvoid/string/FormatCompiler.scala
+++ b/objectformatter/src/main/scala/net/virtualvoid/string/FormatCompiler.scala
@@ -7,24 +7,17 @@ object Compiler{
   import net.virtualvoid.bytecode.ASMCompiler
   import Bytecode._
   import Bytecode.Instructions._
-  import Bytecode.Implicits._
 
   val parser = EnhancedStringFormatParser
   import TypedAST._
-  
-  def elementType(it:java.lang.reflect.Type,of:Class[_])
-  	:Class[_ <: AnyRef] = {
-    TypeHelper.genericInstanceType(it,of,Array()) match{
-      case Some(cl:java.lang.Class[AnyRef]) => cl
-      case _ => throw new java.lang.Error("Can't get element type of "+it)
-    }
-  }
 
-  def compileExp[R<:List,T<:AnyRef,Ret](exp:Exp[T,Ret])
+  val append = method2((_:StringBuilder).append(_:String))
+   
+  def compileExp[R<:List,T<:AnyRef,Ret <% NoUnit](exp:Exp[T,Ret])
                                   :F[R**T] => F[R**Ret] =
     exp match {
       case ParentExp(inner,parent) => _ ~ compileExp(parent) ~ compileExp(inner)
-      case MethodHandleExp(handle) => _ ~ handle.invoke
+      case MethodHandleExp(method) => _ ~ method
       case ThisExp => f => f
     }
     
@@ -40,12 +33,12 @@ object Compiler{
                      :F[R**StringBuilder]
     = ele match {
       case Literal(str) => 
-        f ~ ldc(str) ~ invokemethod2(_.append(_))
+        f ~ ldc(str) ~ append
       case ToStringConversion(e) =>
         f ~ value.load ~
           compileExp(e) ~ 
-          invokemethod1(_.toString) ~ 
-          invokemethod2(_.append(_))
+          method1((_:AnyRef).toString) ~ 
+          append
       case ExpandArray(exp,sep,inner) => {
 		  import Bytecode.RichOperations.foldArray
 		  
@@ -68,7 +61,7 @@ object Compiler{
 			            ifne2(
 			              _ ~
 			                ldc(sep) ~
-			                invokemethod2(_.append(_))
+			                append
 			              , nop
 			            )
 			        )
@@ -80,11 +73,11 @@ object Compiler{
             value.load ~
             compileExp(exp) ~
             dup ~
-            invokemethod1(_.isDefined) ~
+            method1((_:Option[AnyRef]).isDefined) ~
             ifeq2(
               _ ~ pop /*None*/ ~ compileFormatElementList(elseB,value),
               _ ~ 
-                invokemethod1(_.get) ~
+                method1((_:Option[AnyRef]).get) ~
                 withLocal(newValue => compileFormatElementList(then,newValue)))
       }
       /*case Expand(exp,sep,inner) => {
@@ -227,7 +220,7 @@ object Compiler{
       _ ~ 
         newInstance(classOf[StringBuilder]) ~
         compileFormatElementList(elements,value) ~
-        invokemethod1(_.toString)
+        method1((_:StringBuilder).toString)
     )
   }
 }
diff --git a/objectformatter/src/main/scala/net/virtualvoid/string/TypedAST.scala b/objectformatter/src/main/scala/net/virtualvoid/string/TypedAST.scala
index 48ab382..db161af 100644
--- a/objectformatter/src/main/scala/net/virtualvoid/string/TypedAST.scala
+++ b/objectformatter/src/main/scala/net/virtualvoid/string/TypedAST.scala
@@ -85,7 +85,7 @@ object TypedAST {
    * a typed ParentExp
    */
   def typedParentExp[T<:AnyRef,U<:AnyRef,V](inner:AST.Exp,innerMethod:java.lang.reflect.Method,cl:Class[T],innerType:Class[U],retCl:Class[V]):Exp[T,V] =
-    ParentExp[T,U,V](typedExp(inner,innerType,retCl),MethodHandleExp(methodHandle(innerMethod,cl,innerType)))
+    ParentExp[T,U,V](typedExp(inner,innerType,retCl),MethodHandleExp(dynMethod(innerMethod,cl,innerType)))
   
   def typedExp[T<:AnyRef,U](exp:AST.Exp,cl:Class[T],retClass:Class[U]):Exp[T,U] = exp match {
     case AST.ThisExp => typedThisExp(cl,retClass)
@@ -94,14 +94,17 @@ object TypedAST {
       val innerType:Class[AnyRef] = innerMethod.getReturnType.asInstanceOf[Class[AnyRef]] //TODO: check that here
       typedParentExp(inner,innerMethod,cl,innerType,retClass)
     }
-    case e:AST.Exp => MethodHandleExp(methodHandle[T,U](e.method(cl),cl,retClass))
+    case e:AST.Exp => MethodHandleExp(dynMethod[T,U](e.method(cl),cl,retClass))
   }
   
   def typedExpandArray[T<:AnyRef,E<:AnyRef](exp:AST.Exp,sep:String,inner:AST.FormatElementList,cl:Class[T],eleClass:Class[E])
   		:ExpandArray[T,E]
     = ExpandArray(typedExp(exp,cl,classOfArray(eleClass)),sep,typed(inner,eleClass))
     
-  //def typedConditionalOption
+  def typedConditionalOption[T<:AnyRef,U<:AnyRef](c:AST.Conditional,cl:Class[T],eleClass:Class[U]):ConditionalOption[T,U] = {
+    val AST.Conditional(exp,thenB,elseB) = c
+    ConditionalOption(typedExp(exp,cl,classOf[Option[U]]),typed(thenB,eleClass),typed(elseB,cl))
+  }
   
   def typed[T<:AnyRef](ast:AST.FormatElementList,cl:Class[T]):FormatElementList[T] = FormatElementList[T](
     ast.elements.map {
@@ -114,16 +117,25 @@ object TypedAST {
         
         typedExpandArray(exp,sep,inner,cl,eleType)
       }
-      /*case AST.Conditional(exp,then,elseT) => {
-        if (classOf[Option].isAssignableFrom(exp.returnType(cl)))
-          
+      case c@AST.Conditional(exp,_,_) => {
+        if (classOf[Option[_]].isAssignableFrom(exp.returnType(cl))){
+          val eleType = elementType(exp.genericReturnType(cl),classOf[Option[_]])
+          typedConditionalOption(c,cl,eleType)
+        }
         else
           throw new RuntimeException("Only Option conditionals supported")
-      }*/
+      }
     }
   )
   
   def classOfArray[T<:AnyRef](eleClass:Class[T]):Class[Array[T]] = Class.forName("[L"+eleClass.getName+";").asInstanceOf[Class[Array[T]]]
+  def elementType(it:java.lang.reflect.Type,of:Class[_])
+  	:Class[_ <: AnyRef] = {
+    TypeHelper.genericInstanceType(it,of,Array()) match{
+      case Some(cl:java.lang.Class[AnyRef]) => cl
+      case _ => throw new java.lang.Error("Can't get element type of "+it)
+    }
+  }
 }
 case class Person(name:String,town:String)
 object IterableHelper {
