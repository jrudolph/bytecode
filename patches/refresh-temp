Bottom: 40d2e5ed3278cfbd5c7df21871b3b02d0ab228b7
Top:    c30f05667d8db1a54af542eb09f555d96866a3e1
Author: Johannes Rudolph <johannes_rudolph@gmx.de>
Date:   2009-10-05 22:28:03 +0200

Refresh of typed

---

diff --git a/objectformatter/src/main/scala/net/virtualvoid/string/FormatCompiler.scala b/objectformatter/src/main/scala/net/virtualvoid/string/FormatCompiler.scala
index ef21cde..cca4b11 100644
--- a/objectformatter/src/main/scala/net/virtualvoid/string/FormatCompiler.scala
+++ b/objectformatter/src/main/scala/net/virtualvoid/string/FormatCompiler.scala
@@ -20,22 +20,22 @@ object Compiler{
     }
   }
 
-  def compileGetExp[R<:List,T,Ret](exp:Exp[T,Ret])
-                                  (f:F[R**T]):F[R**Ret] =
+  def compileExp[R<:List,T<:AnyRef,Ret](exp:Exp[T,Ret])
+                                  :F[R**T] => F[R**Ret] =
     exp match {
-      case p@ParentExp(inner,parent) => f ~ compileGetExp(parent) ~ compileGetExp(inner)
-      case MethodHandleExp(handle) => f ~ handle.invoke
-      case ThisExp => f
+      case ParentExp(inner,parent) => _ ~ compileExp(parent) ~ compileExp(inner)
+      case MethodHandleExp(handle) => _ ~ handle.invoke
+      case ThisExp => f => f
     }
     
   def compileFormatElementList[R<:List,T<:AnyRef]
-                 (elements:FormatElementList[T],value:Local[T])
+                 (elements:FormatElementList[T],value:ROLocal[T])
                  (f:F[R**StringBuilder]):F[R**StringBuilder] =
     elements.elements.foldLeft(f){(frame,element) => 
       compileElement(element,value)(frame)}
 
-  def compileElement[R<:List,T<:AnyRef]
-                     (ele:FormatElement[T],value:Local[T])
+  def compileElement[R<:List,T <: AnyRef]
+                     (ele:FormatElement[T],value:ROLocal[T])
                      (f:F[R**StringBuilder])
                      :F[R**StringBuilder]
     = ele match {
@@ -43,7 +43,7 @@ object Compiler{
         f ~ ldc(str) ~ invokemethod2(_.append(_))
       case ToStringConversion(e) =>
         f ~ value.load ~
-          compileGetExp(e) ~ 
+          compileExp(e) ~ 
           invokemethod1(_.toString) ~ 
           invokemethod2(_.append(_))
       case ExpandArray(exp,sep,inner) => {
@@ -51,27 +51,41 @@ object Compiler{
 		  
 		  f ~
 		    value.load ~
-		    compileGetExp(exp) ~
+		    compileExp(exp) ~
 		    dup ~
-		    arraylength ~
-		    bipush(1) ~
-		    isub ~
-		    withLocal(lastIndex =>
+		    withLocal(array =>
 		      _ ~
-		        swap() ~
-		        foldArray(index =>
-		          _ ~ withLocal(innerValue => compileFormatElementList(inner,innerValue)) ~
-		            lastIndex.load ~
-		            index.load ~
-		            isub ~
-		            ifne2(
-		              _ ~
-		                ldc(sep) ~
-		                invokemethod2(_.append(_))
-		              , f=>f
-		            )
-		        )
-		    )
+			    arraylength ~
+			    bipush(1) ~
+			    isub ~
+			    withLocal(lastIndex =>
+			        foldArray(array)(index =>
+			          _ ~  
+			            withLocal(innerValue => compileFormatElementList(inner,innerValue)) ~
+			            lastIndex.load ~
+			            index.load ~
+			            isub ~
+			            ifne2(
+			              _ ~
+			                ldc(sep) ~
+			                invokemethod2(_.append(_))
+			              , nop
+			            )
+			        )
+			    )
+            )
+      }
+      case ConditionalOption(exp,then,elseB) => {
+        f ~
+            value.load ~
+            compileExp(exp) ~
+            dup ~
+            invokemethod1(_.isDefined) ~
+            ifeq2(
+              _ ~ pop /*None*/ ~ compileFormatElementList(elseB,value),
+              _ ~ 
+                invokemethod1(_.get) ~
+                withLocal(newValue => compileFormatElementList(then,newValue)))
       }
       /*case Expand(exp,sep,inner) => {
         import Bytecode.RichOperations.foldIterator
diff --git a/objectformatter/src/main/scala/net/virtualvoid/string/TypedAST.scala b/objectformatter/src/main/scala/net/virtualvoid/string/TypedAST.scala
index 8aa54ae..48ab382 100644
--- a/objectformatter/src/main/scala/net/virtualvoid/string/TypedAST.scala
+++ b/objectformatter/src/main/scala/net/virtualvoid/string/TypedAST.scala
@@ -10,7 +10,7 @@ object TypedAST {
   case object ThisExp extends Exp[Any,Any]{
     override def eval(o:Any) = o
   }
-  case class ParentExp[T,U,V](inner:Exp[U,V],parent:Exp[T,U]) extends Exp[T,V]{
+  case class ParentExp[T<:AnyRef,U<:AnyRef,V](inner:Exp[U,V],parent:Exp[T,U]) extends Exp[T,V]{
     override def eval(o:T) = inner.eval(parent.eval(o))
   }
   case class MethodHandleExp[-T,+U](m:Method1[T,U]) extends Exp[T,U] {
@@ -28,7 +28,7 @@ object TypedAST {
     def convert(o:U):String
     def format(o:T):String = convert(exp.eval(o))
   }
-  case class ToStringConversion[T](exp:Exp[T,AnyRef]) extends Conversion[T,AnyRef](exp){
+  case class ToStringConversion[T<:AnyRef](exp:Exp[T,AnyRef]) extends Conversion[T,AnyRef](exp){
     def convert(o:AnyRef) = o.toString
   }/*
   case class Conditional(condition:Exp,thenToks:FormatElementList,elseToks:FormatElementList) extends FormatElement{
@@ -49,6 +49,12 @@ object TypedAST {
     })
     def chars = ""
   }*/
+  case class ConditionalOption[T<:AnyRef,U<:AnyRef](exp:Exp[T,Option[U]],thenToks:FormatElementList[U],elseToks:FormatElementList[T]) extends FormatElement[T]{
+    override def format(o:T):String = exp(o) match{
+      case Some(x) => thenToks.format(x)
+      case None => elseToks.format(o)
+    }
+  }
   abstract class Expand[T,C[_],U](exp:Exp[T,C[U]],sep:String,inner:FormatElementList[U]) extends Conversion[T,C[U]](exp){
     def asIterable(c:C[U]):Iterable[U]
     override def convert(i:C[U]) = asIterable(i) map (inner.format _) mkString sep
@@ -78,24 +84,26 @@ object TypedAST {
    * checks that outer expression fits nicely around the inner expression and then builds
    * a typed ParentExp
    */
-  def typedParentExp[T,U,V](inner:AST.Exp,innerMethod:java.lang.reflect.Method,cl:Class[T],innerType:Class[U],retCl:Class[V]):Exp[T,V] =
+  def typedParentExp[T<:AnyRef,U<:AnyRef,V](inner:AST.Exp,innerMethod:java.lang.reflect.Method,cl:Class[T],innerType:Class[U],retCl:Class[V]):Exp[T,V] =
     ParentExp[T,U,V](typedExp(inner,innerType,retCl),MethodHandleExp(methodHandle(innerMethod,cl,innerType)))
   
-  def typedExp[T,U](exp:AST.Exp,cl:Class[T],retClass:Class[U]):Exp[T,U] = exp match {
+  def typedExp[T<:AnyRef,U](exp:AST.Exp,cl:Class[T],retClass:Class[U]):Exp[T,U] = exp match {
     case AST.ThisExp => typedThisExp(cl,retClass)
     case p@AST.ParentExp(inner,parent) => {
       val innerMethod = p.method(cl)
-      val innerType = innerMethod.getReturnType
+      val innerType:Class[AnyRef] = innerMethod.getReturnType.asInstanceOf[Class[AnyRef]] //TODO: check that here
       typedParentExp(inner,innerMethod,cl,innerType,retClass)
     }
     case e:AST.Exp => MethodHandleExp(methodHandle[T,U](e.method(cl),cl,retClass))
   }
   
-  def typedExpandArray[T,E<:AnyRef](exp:AST.Exp,sep:String,inner:AST.FormatElementList,cl:Class[T],eleClass:Class[E])
+  def typedExpandArray[T<:AnyRef,E<:AnyRef](exp:AST.Exp,sep:String,inner:AST.FormatElementList,cl:Class[T],eleClass:Class[E])
   		:ExpandArray[T,E]
     = ExpandArray(typedExp(exp,cl,classOfArray(eleClass)),sep,typed(inner,eleClass))
+    
+  //def typedConditionalOption
   
-  def typed[T](ast:AST.FormatElementList,cl:Class[T]):FormatElementList[T] = FormatElementList[T](
+  def typed[T<:AnyRef](ast:AST.FormatElementList,cl:Class[T]):FormatElementList[T] = FormatElementList[T](
     ast.elements.map {
       case AST.Literal(str) => Literal(str)
       case AST.ToStringConversion(exp) => ToStringConversion(typedExp(exp,cl,classOf[AnyRef]))
@@ -106,6 +114,12 @@ object TypedAST {
         
         typedExpandArray(exp,sep,inner,cl,eleType)
       }
+      /*case AST.Conditional(exp,then,elseT) => {
+        if (classOf[Option].isAssignableFrom(exp.returnType(cl)))
+          
+        else
+          throw new RuntimeException("Only Option conditionals supported")
+      }*/
     }
   )
