Bottom: 25f5b1ce5b96d201bcf089e6e24a04d3330d59cd
Top:    f15b0220168dcf9c69206b25302ba5043f355858
Author: Johannes Rudolph <johannes_rudolph@gmx.de>
Date:   2009-10-05 12:13:32 +0200

Refresh of typed

---

diff --git a/objectformatter/src/main/scala/net/virtualvoid/string/FormatCompiler.scala b/objectformatter/src/main/scala/net/virtualvoid/string/FormatCompiler.scala
index 4f93a51..b391e92 100644
--- a/objectformatter/src/main/scala/net/virtualvoid/string/FormatCompiler.scala
+++ b/objectformatter/src/main/scala/net/virtualvoid/string/FormatCompiler.scala
@@ -10,7 +10,7 @@ object Compiler{
   import Bytecode.Implicits._
 
   val parser = EnhancedStringFormatParser
-  import AST._
+  import TypedAST._
   
   def elementType(it:java.lang.reflect.Type,of:Class[_])
   	:Class[_ <: AnyRef] = {
@@ -20,11 +20,16 @@ object Compiler{
     }
   }
 
-  def compileGetExp[R<:List,LR<:List,T,Ret](exp:Exp
-                                            ,cl:Class[T]
-                                            ,retType:Class[Ret])
-                                           (f:F[R**T]):F[R**Ret] = 
-  exp match {
+  def compileGetExp[R<:List,LR<:List,T,Ret](exp:Exp[T,Ret])
+                                            //,cl:Class[T]
+                                            //,retType:Class[Ret])
+                                           (f:F[R**T]):F[R**Ret] =
+    exp match {
+      case p@ParentExp(inner,parent) => f ~ compileGetExp(parent) ~ compileGetExp(inner)
+      case MethodHandleExp(handle) => f ~ handle.invoke
+      case ThisExp(retCl) => f ~ checkcast(retCl)
+    }                                             
+  /*exp match {
     case p@ParentExp(inner,parent) =>{
       val m = Bytecode.methodHandle[T,Object](p.method(cl),cl,classOf[Object])
       f ~ 
@@ -39,18 +44,18 @@ object Compiler{
       f ~ 
         m.invoke
     }
-  }
+  }*/
     
-  def compileFormatElementList[R<:List,LR<:List,T<:java.lang.Object]
-                 (elements:FormatElementList,cl:Class[T],value:Local[T])
+  def compileFormatElementList[R<:List,T<:AnyRef]
+                 (elements:FormatElementList[T],value:Local[T])
                  (f:F[R**StringBuilder]):F[R**StringBuilder] =
     elements.elements.foldLeft(f){(frame,element) => 
-      compileElement(element,cl,value)(frame)}
+      compileElement(element,value)(frame)}
 
   def id[X]:X=>X = x=>x
   
-  def compileElement[R<:List,LR<:List,T<:java.lang.Object]
-                     (ele:FormatElement,cl:Class[T],value:Local[T])
+  def compileElement[R<:List,T<:AnyRef]
+                     (ele:FormatElement[T],value:Local[T])
                      (f:F[R**StringBuilder])
                      :F[R**StringBuilder]
     = ele match {
@@ -58,10 +63,42 @@ object Compiler{
         f ~ ldc(str) ~ invokemethod2(_.append(_))
       case ToStringConversion(e) =>
         f ~ value.load ~
-          compileGetExp(e,cl,classOf[AnyRef]) ~ 
+          compileGetExp(e) ~ 
           invokemethod1(_.toString) ~ 
           invokemethod2(_.append(_))
-      case Expand(exp,sep,inner) => {
+      case ExpandArray(exp,sep,inner) => {
+        /*val eleType:Class[AnyRef] = retType.getComponentType.asInstanceOf[Class[AnyRef]]
+
+          if (eleType.isPrimitive)
+            throw new java.lang.Error("can't handle primitive arrays right now");*/
+
+          import Bytecode.RichOperations.foldArray
+          
+          f ~
+            value.load ~
+            compileGetExp(exp) ~
+            dup ~
+            arraylength ~
+            bipush(1) ~
+            isub ~
+            withLocal(lastIndex =>
+              _ ~
+	            swap() ~
+	            foldArray(index =>
+	              _ ~ withLocal(innerValue => compileFormatElementList(inner,innerValue)) ~
+                    lastIndex.load ~
+                    index.load ~
+                    isub ~
+                    ifne2(
+                      _ ~
+                        ldc(sep) ~
+                        invokemethod2(_.append(_))
+                      , f=>f
+                    )
+	            )
+            )
+      }
+      /*case Expand(exp,sep,inner) => {
         import Bytecode.RichOperations.foldIterator
           
         val retType = exp.returnType(cl)
@@ -124,8 +161,8 @@ object Compiler{
         else
           throw new java.lang.Error("can only iterate over "+
                                       "iterables and arrays right now")
-      }
-      case Conditional(inner,thens,elses) => {
+      }*/
+      /*case Conditional(inner,thens,elses) => {
         val retType = inner.returnType(cl)
 
         if (retType == java.lang.Boolean.TYPE || 
@@ -193,14 +230,14 @@ object Compiler{
           ) ~
           invokemethod2(_.format(_)) ~
           invokemethod2(_.append(_))
-      }
+      }*/
     }
   def compile[T<:AnyRef](format:String,cl:Class[T]):T=>jString = {
-    val elements:FormatElementList = parser.parse(format)
+    val elements:FormatElementList[T] = typed(parser.parse(format),cl)
     ASMCompiler.compile(cl)(value =>
       _ ~ 
         newInstance(classOf[StringBuilder]) ~
-        compileFormatElementList(elements,cl,value) ~
+        compileFormatElementList(elements,value) ~
         invokemethod1(_.toString)
     )
   }
diff --git a/objectformatter/src/main/scala/net/virtualvoid/string/TypedAST.scala b/objectformatter/src/main/scala/net/virtualvoid/string/TypedAST.scala
index bc87762..7f3f0a4 100644
--- a/objectformatter/src/main/scala/net/virtualvoid/string/TypedAST.scala
+++ b/objectformatter/src/main/scala/net/virtualvoid/string/TypedAST.scala
@@ -7,8 +7,8 @@ object TypedAST {
 	def eval(o:T):U
 	override def apply(o:T):U = eval(o) 
   }
-  case class ThisExp[T]() extends Exp[T,T]{
-    override def eval(o:T) = o
+  case class ThisExp[T,U](retClass:Class[U]) extends Exp[T,U]{
+    override def eval(o:T) = o.asInstanceOf[U]
   }
   case class ParentExp[T,U,V](inner:Exp[U,V],parent:Exp[T,U]) extends Exp[T,V]{
     override def eval(o:T) = inner.eval(parent.eval(o))
@@ -51,9 +51,9 @@ object TypedAST {
   }*/
   abstract class Expand[T,C[_],U](exp:Exp[T,C[U]],sep:String,inner:FormatElementList[U]) extends Conversion[T,C[U]](exp){
     def asIterable(c:C[U]):Iterable[U]
-    override def convert(i:C[U]) = asIterable(i) map (inner.format _) mkString ""
+    override def convert(i:C[U]) = asIterable(i) map (inner.format _) mkString sep
   }
-  case class ExpandArray[T,U](exp:Exp[T,Array[U]],sep:String,inner:FormatElementList[U]) extends Expand[T,Array,U](exp,sep,inner){
+  case class ExpandArray[T,U<:AnyRef](exp:Exp[T,Array[U]],sep:String,inner:FormatElementList[U]) extends Expand[T,Array,U](exp,sep,inner){
     override def asIterable(i:Array[U]) = i
   }
   case class ExpandJavaIterable[T,U](exp:Exp[T,java.lang.Iterable[U]],sep:String,inner:FormatElementList[U]) extends Expand[T,java.lang.Iterable,U](exp,sep,inner){
@@ -70,7 +70,7 @@ object TypedAST {
    */
   def typedThisExp[T,U](cl:Class[T],retCl:Class[U]):Exp[T,U] =
     if (retCl.isAssignableFrom(cl))
-      ThisExp[T].asInstanceOf[Exp[T,U]] // we checked it
+      ThisExp(retCl)
     else
       throw new TypingException("#this has not the expected type "+retCl)
   
@@ -101,6 +101,9 @@ object TypedAST {
       case AST.ToStringConversion(exp) => ToStringConversion(typedExp(exp,cl,classOf[AnyRef]))
       case AST.Expand(exp,sep,inner) => {
         val eleType:Class[AnyRef] = exp.returnType(cl).getComponentType.asInstanceOf[Class[AnyRef]]
+        if (eleType == null)
+          throw new RuntimeException(exp+" must evaluate into an array but is "+exp.returnType(cl))
+        
         typedExpandArray(exp,sep,inner,cl,eleType)
       }
     }
@@ -108,7 +111,7 @@ object TypedAST {
   
   def classOfArray[T<:AnyRef](eleClass:Class[T]):Class[Array[T]] = Class.forName("[L"+eleClass.getName+";").asInstanceOf[Class[Array[T]]]
 }
-
+case class Person(name:String,town:String)
 object IterableHelper {
   implicit def java2scala[T](it:java.lang.Iterable[T]):Iterable[T] = new Iterable[T]{
     override def elements:Iterator[T] = new Iterator[T]{
@@ -118,3 +121,10 @@ object IterableHelper {
     }
   }
 }
+
+/*
+import net.virtualvoid.string._
+val ast = EnhancedStringFormatParser parse "#this[#name lives in #town]{,}*"
+TypedAST.typed(ast,classOf[Array[Person]])
+ 
+ */
