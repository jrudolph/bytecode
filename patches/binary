Bottom: 0e7f030794721ffc113d0f2a3a6287d8bb10c752
Top:    13f961e9593a9e782e81af28899281bf04f851b5
Author: Johannes Rudolph <johannes_rudolph@gmx.de>
Date:   2009-09-29 16:36:45 +0200

binary function generation support


---

diff --git a/bytecode/src/main/scala/net/virtualvoid/bytecode/Bytecode.scala b/bytecode/src/main/scala/net/virtualvoid/bytecode/Bytecode.scala
index 5028d8a..6f9fe6e 100644
--- a/bytecode/src/main/scala/net/virtualvoid/bytecode/Bytecode.scala
+++ b/bytecode/src/main/scala/net/virtualvoid/bytecode/Bytecode.scala
@@ -268,6 +268,9 @@ object Bytecode{
 	  def compile[T<:AnyRef,U<:AnyRef](cl:Class[T])(
                        code: Local[T] => F[Nil] => F[Nil**U]   
 	  ): T => U
+	  def compile[T1<:AnyRef,T2<:AnyRef,U<:AnyRef](cl1:Class[T1],cl2:Class[T2])(
+	    code: (Local[T1],Local[T2]) => F[Nil] => F[Nil**U]
+	  ): (T1,T2) => U
   }
 
   trait RichFunc[ST1<:List,ST2<:List] 
diff --git a/bytecode/src/main/scala/net/virtualvoid/bytecode/Compiler.scala b/bytecode/src/main/scala/net/virtualvoid/bytecode/Compiler.scala
index ab98020..43f8b67 100644
--- a/bytecode/src/main/scala/net/virtualvoid/bytecode/Compiler.scala
+++ b/bytecode/src/main/scala/net/virtualvoid/bytecode/Compiler.scala
@@ -298,6 +298,13 @@ object ASMCompiler extends ByteletCompiler{
         code(local(1,cl))(new ASMFrame[Nil](mv,EmptyClassStack,2))
       }
     }
+    def compile[T1<:AnyRef,T2<:AnyRef,U<:AnyRef](cl1:Class[T1],cl2:Class[T2])(
+	    code: (Local[T1],Local[T2]) => F[Nil] => F[Nil**U]
+	  ): (T1,T2) => U = {
+      classStub[(T1,T2)=>U](cl1,cl2){ mv =>
+        code(local(1,cl1),local(2,cl2))(new ASMFrame[Nil](mv,EmptyClassStack,3))
+      }
+    }
     def classStub[T](params:Class[_]*)(body: MethodVisitor => Unit) :T = {
       val numParams = params.length
       val superClass = "net/virtualvoid/bytecode/AbstractFunction"+numParams
@@ -349,3 +356,4 @@ object ASMCompiler extends ByteletCompiler{
   }
 
 abstract class AbstractFunction1[T,U] extends Function1[T,U]
+abstract class AbstractFunction2[T1,T2,U] extends Function2[T1,T2,U]
\ No newline at end of file
diff --git a/bytecode/src/main/scala/net/virtualvoid/bytecode/Interpreter.scala b/bytecode/src/main/scala/net/virtualvoid/bytecode/Interpreter.scala
index b5974aa..f8555f0 100644
--- a/bytecode/src/main/scala/net/virtualvoid/bytecode/Interpreter.scala
+++ b/bytecode/src/main/scala/net/virtualvoid/bytecode/Interpreter.scala
@@ -4,7 +4,7 @@ import Bytecode._
 
 import java.lang.{String=>jString}
 
-object Interpreter extends ByteletCompiler{
+object Interpreter extends ByteletCompiler {
     case class IF[+ST<:List](stack:ST) extends F[ST]{
       import CodeTools._
       
@@ -108,24 +108,26 @@ object Interpreter extends ByteletCompiler{
           // classical y combinator in strict languages
           func(tailRecursive_int(func)_)(fr)
       
-      def withLocal_int[T,ST<:List,ST2<:List](top:T,rest:ST,code:Local[T]=>F[ST]=>F[ST2]):F[ST2] = {
-        var value = top
-        code(new Local[T]{
-          def load[ST<:List]:F[ST] => F[ST**T] = f => IF(f.stack**value)
-          def store[ST<:List]:F[ST**T] => F[ST] = f => {
-            value = f.stack.top
-            IF(f.stack.rest)
-          }
-        })(IF(rest))
-      }
+      def withLocal_int[T,ST<:List,ST2<:List](top:T,rest:ST,code:Local[T]=>F[ST]=>F[ST2]):F[ST2] =
+        code(local(top))(IF(rest))
     }
 
+    def local[T](initial:T):Local[T] = new Local[T] {
+      var value = initial
+      def load[ST<:List]:F[ST] => F[ST**T] = f => IF(f.stack**value)
+      def store[ST<:List]:F[ST**T] => F[ST] = f => {
+    	  value = f.stack.top
+    	  IF(f.stack.rest)
+      }
+    } 
+    
     def compile[T<:AnyRef,U<:AnyRef](cl:Class[T])(
                        code: Local[T] => F[Nil] => F[Nil**U]   
 	  ): T => U =
-      t => code(new Local[T]{
-        var value = t
-        def load[ST<:List]:F[ST] => F[ST**T] = f => IF(f.stack**value)
-        def store[ST<:List]:F[ST**T] => F[ST] = f => {value = f.stack.top; IF(f.stack.rest)}
-      })(IF(N)).stack.top
-  }
\ No newline at end of file
+      t => code(local(t))(IF(N)).stack.top
+    
+    def compile[T1<:AnyRef,T2<:AnyRef,U<:AnyRef](cl1:Class[T1],cl2:Class[T2])(
+	    code: (Local[T1],Local[T2]) => F[Nil] => F[Nil**U]
+	  ): (T1,T2) => U = 
+      (t1,t2) => code(local(t1),local(t2))(IF(N)).stack.top
+}
\ No newline at end of file
diff --git a/bytecode/src/test/scala/net/virtualvoid/bytecode/BytecodeCompilerSpecs.scala b/bytecode/src/test/scala/net/virtualvoid/bytecode/BytecodeCompilerSpecs.scala
index c3327a4..d7889b9 100644
--- a/bytecode/src/test/scala/net/virtualvoid/bytecode/BytecodeCompilerSpecs.scala
+++ b/bytecode/src/test/scala/net/virtualvoid/bytecode/BytecodeCompilerSpecs.scala
@@ -234,6 +234,14 @@ object BytecodeCompilerSpecs extends Specification{
       f(null) must be_==("isnull")
       f("blub") must be_==("blub isnotnull")
     }
+    "binary methods" in {
+      compiler.compile(classOf[String],classOf[String])((str1,str2) =>
+        _ ~
+          str1.load ~
+          str2.load ~
+          invokemethod2(_.concat(_))
+      )("String1","String2") must be_==("String1String2")
+    }
   }
   def array(els:Int*):Array[Int] = Array(els:_*)
   def array(els:String*):Array[String] = Array(els:_*)
