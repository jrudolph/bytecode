Bottom: c165f1d3c2775d18024b1d251a99f9540cd557fc
Top:    f15b0220168dcf9c69206b25302ba5043f355858
Author: Johannes Rudolph <johannes_rudolph@gmx.de>
Date:   2009-10-05 11:44:03 +0200

checkpoint


---

diff --git a/objectformatter/src/main/scala/net/virtualvoid/string/FormatCompiler.scala b/objectformatter/src/main/scala/net/virtualvoid/string/FormatCompiler.scala
index 4f93a51..b391e92 100644
--- a/objectformatter/src/main/scala/net/virtualvoid/string/FormatCompiler.scala
+++ b/objectformatter/src/main/scala/net/virtualvoid/string/FormatCompiler.scala
@@ -10,7 +10,7 @@ object Compiler{
   import Bytecode.Implicits._
 
   val parser = EnhancedStringFormatParser
-  import AST._
+  import TypedAST._
   
   def elementType(it:java.lang.reflect.Type,of:Class[_])
   	:Class[_ <: AnyRef] = {
@@ -20,11 +20,16 @@ object Compiler{
     }
   }
 
-  def compileGetExp[R<:List,LR<:List,T,Ret](exp:Exp
-                                            ,cl:Class[T]
-                                            ,retType:Class[Ret])
-                                           (f:F[R**T]):F[R**Ret] = 
-  exp match {
+  def compileGetExp[R<:List,LR<:List,T,Ret](exp:Exp[T,Ret])
+                                            //,cl:Class[T]
+                                            //,retType:Class[Ret])
+                                           (f:F[R**T]):F[R**Ret] =
+    exp match {
+      case p@ParentExp(inner,parent) => f ~ compileGetExp(parent) ~ compileGetExp(inner)
+      case MethodHandleExp(handle) => f ~ handle.invoke
+      case ThisExp(retCl) => f ~ checkcast(retCl)
+    }                                             
+  /*exp match {
     case p@ParentExp(inner,parent) =>{
       val m = Bytecode.methodHandle[T,Object](p.method(cl),cl,classOf[Object])
       f ~ 
@@ -39,18 +44,18 @@ object Compiler{
       f ~ 
         m.invoke
     }
-  }
+  }*/
     
-  def compileFormatElementList[R<:List,LR<:List,T<:java.lang.Object]
-                 (elements:FormatElementList,cl:Class[T],value:Local[T])
+  def compileFormatElementList[R<:List,T<:AnyRef]
+                 (elements:FormatElementList[T],value:Local[T])
                  (f:F[R**StringBuilder]):F[R**StringBuilder] =
     elements.elements.foldLeft(f){(frame,element) => 
-      compileElement(element,cl,value)(frame)}
+      compileElement(element,value)(frame)}
 
   def id[X]:X=>X = x=>x
   
-  def compileElement[R<:List,LR<:List,T<:java.lang.Object]
-                     (ele:FormatElement,cl:Class[T],value:Local[T])
+  def compileElement[R<:List,T<:AnyRef]
+                     (ele:FormatElement[T],value:Local[T])
                      (f:F[R**StringBuilder])
                      :F[R**StringBuilder]
     = ele match {
@@ -58,10 +63,42 @@ object Compiler{
         f ~ ldc(str) ~ invokemethod2(_.append(_))
       case ToStringConversion(e) =>
         f ~ value.load ~
-          compileGetExp(e,cl,classOf[AnyRef]) ~ 
+          compileGetExp(e) ~ 
           invokemethod1(_.toString) ~ 
           invokemethod2(_.append(_))
-      case Expand(exp,sep,inner) => {
+      case ExpandArray(exp,sep,inner) => {
+        /*val eleType:Class[AnyRef] = retType.getComponentType.asInstanceOf[Class[AnyRef]]
+
+          if (eleType.isPrimitive)
+            throw new java.lang.Error("can't handle primitive arrays right now");*/
+
+          import Bytecode.RichOperations.foldArray
+          
+          f ~
+            value.load ~
+            compileGetExp(exp) ~
+            dup ~
+            arraylength ~
+            bipush(1) ~
+            isub ~
+            withLocal(lastIndex =>
+              _ ~
+	            swap() ~
+	            foldArray(index =>
+	              _ ~ withLocal(innerValue => compileFormatElementList(inner,innerValue)) ~
+                    lastIndex.load ~
+                    index.load ~
+                    isub ~
+                    ifne2(
+                      _ ~
+                        ldc(sep) ~
+                        invokemethod2(_.append(_))
+                      , f=>f
+                    )
+	            )
+            )
+      }
+      /*case Expand(exp,sep,inner) => {
         import Bytecode.RichOperations.foldIterator
           
         val retType = exp.returnType(cl)
@@ -124,8 +161,8 @@ object Compiler{
         else
           throw new java.lang.Error("can only iterate over "+
                                       "iterables and arrays right now")
-      }
-      case Conditional(inner,thens,elses) => {
+      }*/
+      /*case Conditional(inner,thens,elses) => {
         val retType = inner.returnType(cl)
 
         if (retType == java.lang.Boolean.TYPE || 
@@ -193,14 +230,14 @@ object Compiler{
           ) ~
           invokemethod2(_.format(_)) ~
           invokemethod2(_.append(_))
-      }
+      }*/
     }
   def compile[T<:AnyRef](format:String,cl:Class[T]):T=>jString = {
-    val elements:FormatElementList = parser.parse(format)
+    val elements:FormatElementList[T] = typed(parser.parse(format),cl)
     ASMCompiler.compile(cl)(value =>
       _ ~ 
         newInstance(classOf[StringBuilder]) ~
-        compileFormatElementList(elements,cl,value) ~
+        compileFormatElementList(elements,value) ~
         invokemethod1(_.toString)
     )
   }
diff --git a/objectformatter/src/main/scala/net/virtualvoid/string/TypedAST.scala b/objectformatter/src/main/scala/net/virtualvoid/string/TypedAST.scala
new file mode 100644
index 0000000..7f3f0a4
--- /dev/null
+++ b/objectformatter/src/main/scala/net/virtualvoid/string/TypedAST.scala
@@ -0,0 +1,130 @@
+package net.virtualvoid.string
+
+import _root_.net.virtualvoid.bytecode.Bytecode._
+
+object TypedAST {
+  trait Exp[-T,+U] extends (T => U){
+	def eval(o:T):U
+	override def apply(o:T):U = eval(o) 
+  }
+  case class ThisExp[T,U](retClass:Class[U]) extends Exp[T,U]{
+    override def eval(o:T) = o.asInstanceOf[U]
+  }
+  case class ParentExp[T,U,V](inner:Exp[U,V],parent:Exp[T,U]) extends Exp[T,V]{
+    override def eval(o:T) = inner.eval(parent.eval(o))
+  }
+  case class MethodHandleExp[-T,+U](m:Method1[T,U]) extends Exp[T,U] {
+    override def eval(o:T) = m.method.invoke(o).asInstanceOf[U]
+  }
+  
+  trait FormatElement[-T] extends (T => String){
+    def format(o:T):String
+    override def apply(o:T):String = format(o)
+  }  
+  case class Literal(str:String) extends FormatElement[Any]{
+    def format(o:Any):String = str
+  }
+  abstract class Conversion[T,U](exp:Exp[T,U]) extends FormatElement[T]{
+    def convert(o:U):String
+    def format(o:T):String = convert(exp.eval(o))
+  }
+  case class ToStringConversion[T](exp:Exp[T,AnyRef]) extends Conversion[T,AnyRef](exp){
+    def convert(o:AnyRef) = o.toString
+  }/*
+  case class Conditional(condition:Exp,thenToks:FormatElementList,elseToks:FormatElementList) extends FormatElement{
+    def chars =""
+    def format(o:AnyRef) = condition.eval(o) match {
+      case java.lang.Boolean.TRUE => thenToks.format(o)
+      case java.lang.Boolean.FALSE => elseToks.format(o)
+      case x:Option[AnyRef] => x.map(thenToks.format).getOrElse(elseToks.format(o))
+      case null => elseToks.format(o)
+      case x => thenToks.format(x)
+    }
+  }
+  case class DateConversion(exp:Exp,format:String) extends FormatElement{
+    val df = new java.text.SimpleDateFormat(format)
+    def format(o:AnyRef) = df.format(exp.eval(o) match {
+      case cal:java.util.Calendar => cal.getTime
+      case date:java.util.Date => date
+    })
+    def chars = ""
+  }*/
+  abstract class Expand[T,C[_],U](exp:Exp[T,C[U]],sep:String,inner:FormatElementList[U]) extends Conversion[T,C[U]](exp){
+    def asIterable(c:C[U]):Iterable[U]
+    override def convert(i:C[U]) = asIterable(i) map (inner.format _) mkString sep
+  }
+  case class ExpandArray[T,U<:AnyRef](exp:Exp[T,Array[U]],sep:String,inner:FormatElementList[U]) extends Expand[T,Array,U](exp,sep,inner){
+    override def asIterable(i:Array[U]) = i
+  }
+  case class ExpandJavaIterable[T,U](exp:Exp[T,java.lang.Iterable[U]],sep:String,inner:FormatElementList[U]) extends Expand[T,java.lang.Iterable,U](exp,sep,inner){
+    override def asIterable(i:java.lang.Iterable[U]) = IterableHelper.java2scala(i)
+  }
+  case class FormatElementList[T](elements:Seq[FormatElement[T]]){
+    def format(o:T):String = elements.map(_.format(o)) mkString "" 
+  }
+  
+  class TypingException(msg:String) extends RuntimeException(msg)
+  
+  /**
+   * checks that `this` can be (up)casted to the desired return type
+   */
+  def typedThisExp[T,U](cl:Class[T],retCl:Class[U]):Exp[T,U] =
+    if (retCl.isAssignableFrom(cl))
+      ThisExp(retCl)
+    else
+      throw new TypingException("#this has not the expected type "+retCl)
+  
+  /**
+   * checks that outer expression fits nicely around the inner expression and then builds
+   * a typed ParentExp
+   */
+  def typedParentExp[T,U,V](inner:AST.Exp,innerMethod:java.lang.reflect.Method,cl:Class[T],innerType:Class[U],retCl:Class[V]):Exp[T,V] =
+    ParentExp[T,U,V](typedExp(inner,innerType,retCl),MethodHandleExp(methodHandle(innerMethod,cl,innerType)))
+  
+  def typedExp[T,U](exp:AST.Exp,cl:Class[T],retClass:Class[U]):Exp[T,U] = exp match {
+    case AST.ThisExp => typedThisExp(cl,retClass)
+    case p@AST.ParentExp(inner,parent) => {
+      val innerMethod = p.method(cl)
+      val innerType = innerMethod.getReturnType
+      typedParentExp(inner,innerMethod,cl,innerType,retClass)
+    }
+    case e:AST.Exp => MethodHandleExp(methodHandle[T,U](e.method(cl),cl,retClass))
+  }
+  
+  def typedExpandArray[T,E<:AnyRef](exp:AST.Exp,sep:String,inner:AST.FormatElementList,cl:Class[T],eleClass:Class[E])
+  		:ExpandArray[T,E]
+    = ExpandArray(typedExp(exp,cl,classOfArray(eleClass)),sep,typed(inner,eleClass))
+  
+  def typed[T](ast:AST.FormatElementList,cl:Class[T]):FormatElementList[T] = FormatElementList[T](
+    ast.elements.map {
+      case AST.Literal(str) => Literal(str)
+      case AST.ToStringConversion(exp) => ToStringConversion(typedExp(exp,cl,classOf[AnyRef]))
+      case AST.Expand(exp,sep,inner) => {
+        val eleType:Class[AnyRef] = exp.returnType(cl).getComponentType.asInstanceOf[Class[AnyRef]]
+        if (eleType == null)
+          throw new RuntimeException(exp+" must evaluate into an array but is "+exp.returnType(cl))
+        
+        typedExpandArray(exp,sep,inner,cl,eleType)
+      }
+    }
+  )
+  
+  def classOfArray[T<:AnyRef](eleClass:Class[T]):Class[Array[T]] = Class.forName("[L"+eleClass.getName+";").asInstanceOf[Class[Array[T]]]
+}
+case class Person(name:String,town:String)
+object IterableHelper {
+  implicit def java2scala[T](it:java.lang.Iterable[T]):Iterable[T] = new Iterable[T]{
+    override def elements:Iterator[T] = new Iterator[T]{
+      val underlying = it.iterator
+      override def hasNext = underlying.hasNext
+      override def next = underlying.next
+    }
+  }
+}
+
+/*
+import net.virtualvoid.string._
+val ast = EnhancedStringFormatParser parse "#this[#name lives in #town]{,}*"
+TypedAST.typed(ast,classOf[Array[Person]])
+ 
+ */
