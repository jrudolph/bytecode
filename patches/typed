Bottom: 2144c8dff4716fd61c96f726f648321910032280
Top:    41ae828ea64ce477976c31a43589b8e4b4969a9e
Author: Johannes Rudolph <johannes_rudolph@gmx.de>
Date:   2009-10-05 11:44:03 +0200

checkpoint


---

diff --git a/objectformatter/src/main/scala/net/virtualvoid/string/FormatCompiler.scala b/objectformatter/src/main/scala/net/virtualvoid/string/FormatCompiler.scala
index 4f93a51..90e58f1 100644
--- a/objectformatter/src/main/scala/net/virtualvoid/string/FormatCompiler.scala
+++ b/objectformatter/src/main/scala/net/virtualvoid/string/FormatCompiler.scala
@@ -7,61 +7,80 @@ object Compiler{
   import net.virtualvoid.bytecode.ASMCompiler
   import Bytecode._
   import Bytecode.Instructions._
-  import Bytecode.Implicits._
 
   val parser = EnhancedStringFormatParser
-  import AST._
-  
-  def elementType(it:java.lang.reflect.Type,of:Class[_])
-  	:Class[_ <: AnyRef] = {
-    TypeHelper.genericInstanceType(it,of,Array()) match{
-      case Some(cl:java.lang.Class[AnyRef]) => cl
-      case _ => throw new java.lang.Error("Can't get element type of "+it)
-    }
-  }
+  import TypedAST._
 
-  def compileGetExp[R<:List,LR<:List,T,Ret](exp:Exp
-                                            ,cl:Class[T]
-                                            ,retType:Class[Ret])
-                                           (f:F[R**T]):F[R**Ret] = 
-  exp match {
-    case p@ParentExp(inner,parent) =>{
-      val m = Bytecode.methodHandle[T,Object](p.method(cl),cl,classOf[Object])
-      f ~ 
-        m.invoke ~ 
-        compileGetExp(inner,m.method.getReturnType.asInstanceOf[Class[Object]],retType)
+  val append = method2((_:StringBuilder).append(_:String))
+   
+  def compileExp[R<:List,T<:AnyRef,Ret <% NoUnit](exp:Exp[T,Ret])
+                                  :F[R**T] => F[R**Ret] =
+    exp match {
+      case ParentExp(inner,parent) => _ ~ compileExp(parent) ~ compileExp(inner)
+      case MethodHandleExp(method) => _ ~ method
+      case ThisExp => f => f
     }
-    case ThisExp =>
-      f ~ 
-        checkcast(retType) // TODO: don't know why we need this, examine it
-    case e:Exp => {
-      val m = Bytecode.methodHandle[T,Ret](e.method(cl),cl,retType)
-      f ~ 
-        m.invoke
-    }
-  }
     
-  def compileFormatElementList[R<:List,LR<:List,T<:java.lang.Object]
-                 (elements:FormatElementList,cl:Class[T],value:Local[T])
+  def compileFormatElementList[R<:List,T<:AnyRef]
+                 (elements:FormatElementList[T],value:ROLocal[T])
                  (f:F[R**StringBuilder]):F[R**StringBuilder] =
     elements.elements.foldLeft(f){(frame,element) => 
-      compileElement(element,cl,value)(frame)}
+      compileElement(element,value)(frame)}
 
-  def id[X]:X=>X = x=>x
-  
-  def compileElement[R<:List,LR<:List,T<:java.lang.Object]
-                     (ele:FormatElement,cl:Class[T],value:Local[T])
+  def compileElement[R<:List,T <: AnyRef]
+                     (ele:FormatElement[T],value:ROLocal[T])
                      (f:F[R**StringBuilder])
                      :F[R**StringBuilder]
     = ele match {
       case Literal(str) => 
-        f ~ ldc(str) ~ invokemethod2(_.append(_))
+        f ~ ldc(str) ~ append
       case ToStringConversion(e) =>
         f ~ value.load ~
-          compileGetExp(e,cl,classOf[AnyRef]) ~ 
-          invokemethod1(_.toString) ~ 
-          invokemethod2(_.append(_))
-      case Expand(exp,sep,inner) => {
+          compileExp(e) ~ 
+          method1((_:AnyRef).toString) ~ 
+          append
+      case ExpandArray(exp,sep,inner) => {
+		  import Bytecode.RichOperations.foldArray
+		  
+		  f ~
+		    value.load ~
+		    compileExp(exp) ~
+		    dup ~
+		    withLocal(array =>
+		      _ ~
+			    arraylength ~
+			    bipush(1) ~
+			    isub ~
+			    withLocal(lastIndex =>
+			        foldArray(array)(index =>
+			          _ ~  
+			            withLocal(innerValue => compileFormatElementList(inner,innerValue)) ~
+			            lastIndex.load ~
+			            index.load ~
+			            isub ~
+			            ifne2(
+			              _ ~
+			                ldc(sep) ~
+			                append
+			              , nop
+			            )
+			        )
+			    )
+            )
+      }
+      case ConditionalOption(exp,then,elseB) => {
+        f ~
+            value.load ~
+            compileExp(exp) ~
+            dup ~
+            method1((_:Option[AnyRef]).isDefined) ~
+            ifeq2(
+              _ ~ pop /*None*/ ~ compileFormatElementList(elseB,value),
+              _ ~ 
+                method1((_:Option[AnyRef]).get) ~
+                withLocal(newValue => compileFormatElementList(then,newValue)))
+      }
+      /*case Expand(exp,sep,inner) => {
         import Bytecode.RichOperations.foldIterator
           
         val retType = exp.returnType(cl)
@@ -124,8 +143,8 @@ object Compiler{
         else
           throw new java.lang.Error("can only iterate over "+
                                       "iterables and arrays right now")
-      }
-      case Conditional(inner,thens,elses) => {
+      }*/
+      /*case Conditional(inner,thens,elses) => {
         val retType = inner.returnType(cl)
 
         if (retType == java.lang.Boolean.TYPE || 
@@ -193,15 +212,15 @@ object Compiler{
           ) ~
           invokemethod2(_.format(_)) ~
           invokemethod2(_.append(_))
-      }
+      }*/
     }
   def compile[T<:AnyRef](format:String,cl:Class[T]):T=>jString = {
-    val elements:FormatElementList = parser.parse(format)
+    val elements:FormatElementList[T] = typed(parser.parse(format),cl)
     ASMCompiler.compile(cl)(value =>
       _ ~ 
         newInstance(classOf[StringBuilder]) ~
-        compileFormatElementList(elements,cl,value) ~
-        invokemethod1(_.toString)
+        compileFormatElementList(elements,value) ~
+        method1((_:StringBuilder).toString)
     )
   }
 }
diff --git a/objectformatter/src/main/scala/net/virtualvoid/string/TypedAST.scala b/objectformatter/src/main/scala/net/virtualvoid/string/TypedAST.scala
new file mode 100644
index 0000000..db161af
--- /dev/null
+++ b/objectformatter/src/main/scala/net/virtualvoid/string/TypedAST.scala
@@ -0,0 +1,156 @@
+package net.virtualvoid.string
+
+import _root_.net.virtualvoid.bytecode.Bytecode._
+
+object TypedAST {
+  trait Exp[-T,+U] extends (T => U){
+	def eval(o:T):U
+	override def apply(o:T):U = eval(o) 
+  }
+  case object ThisExp extends Exp[Any,Any]{
+    override def eval(o:Any) = o
+  }
+  case class ParentExp[T<:AnyRef,U<:AnyRef,V](inner:Exp[U,V],parent:Exp[T,U]) extends Exp[T,V]{
+    override def eval(o:T) = inner.eval(parent.eval(o))
+  }
+  case class MethodHandleExp[-T,+U](m:Method1[T,U]) extends Exp[T,U] {
+    override def eval(o:T) = m.method.invoke(o).asInstanceOf[U]
+  }
+  
+  trait FormatElement[-T] extends (T => String){
+    def format(o:T):String
+    override def apply(o:T):String = format(o)
+  }  
+  case class Literal(str:String) extends FormatElement[Any]{
+    def format(o:Any):String = str
+  }
+  abstract class Conversion[T,U](exp:Exp[T,U]) extends FormatElement[T]{
+    def convert(o:U):String
+    def format(o:T):String = convert(exp.eval(o))
+  }
+  case class ToStringConversion[T<:AnyRef](exp:Exp[T,AnyRef]) extends Conversion[T,AnyRef](exp){
+    def convert(o:AnyRef) = o.toString
+  }/*
+  case class Conditional(condition:Exp,thenToks:FormatElementList,elseToks:FormatElementList) extends FormatElement{
+    def chars =""
+    def format(o:AnyRef) = condition.eval(o) match {
+      case java.lang.Boolean.TRUE => thenToks.format(o)
+      case java.lang.Boolean.FALSE => elseToks.format(o)
+      case x:Option[AnyRef] => x.map(thenToks.format).getOrElse(elseToks.format(o))
+      case null => elseToks.format(o)
+      case x => thenToks.format(x)
+    }
+  }
+  case class DateConversion(exp:Exp,format:String) extends FormatElement{
+    val df = new java.text.SimpleDateFormat(format)
+    def format(o:AnyRef) = df.format(exp.eval(o) match {
+      case cal:java.util.Calendar => cal.getTime
+      case date:java.util.Date => date
+    })
+    def chars = ""
+  }*/
+  case class ConditionalOption[T<:AnyRef,U<:AnyRef](exp:Exp[T,Option[U]],thenToks:FormatElementList[U],elseToks:FormatElementList[T]) extends FormatElement[T]{
+    override def format(o:T):String = exp(o) match{
+      case Some(x) => thenToks.format(x)
+      case None => elseToks.format(o)
+    }
+  }
+  abstract class Expand[T,C[_],U](exp:Exp[T,C[U]],sep:String,inner:FormatElementList[U]) extends Conversion[T,C[U]](exp){
+    def asIterable(c:C[U]):Iterable[U]
+    override def convert(i:C[U]) = asIterable(i) map (inner.format _) mkString sep
+  }
+  case class ExpandArray[T,U<:AnyRef](exp:Exp[T,Array[U]],sep:String,inner:FormatElementList[U]) extends Expand[T,Array,U](exp,sep,inner){
+    override def asIterable(i:Array[U]) = i
+  }
+  case class ExpandJavaIterable[T,U](exp:Exp[T,java.lang.Iterable[U]],sep:String,inner:FormatElementList[U]) extends Expand[T,java.lang.Iterable,U](exp,sep,inner){
+    override def asIterable(i:java.lang.Iterable[U]) = IterableHelper.java2scala(i)
+  }
+  case class FormatElementList[T](elements:Seq[FormatElement[T]]){
+    def format(o:T):String = elements.map(_.format(o)) mkString "" 
+  }
+  
+  class TypingException(msg:String) extends RuntimeException(msg)
+  
+  /**
+   * checks that `this` can be (up)casted to the desired return type
+   */
+  def typedThisExp[T,U](cl:Class[T],retCl:Class[U]):Exp[T,U] =
+    if (retCl.isAssignableFrom(cl))
+      ThisExp.asInstanceOf[Exp[T,U]] // we checked it
+    else
+      throw new TypingException("#this has not the expected type "+retCl)
+  
+  /**
+   * checks that outer expression fits nicely around the inner expression and then builds
+   * a typed ParentExp
+   */
+  def typedParentExp[T<:AnyRef,U<:AnyRef,V](inner:AST.Exp,innerMethod:java.lang.reflect.Method,cl:Class[T],innerType:Class[U],retCl:Class[V]):Exp[T,V] =
+    ParentExp[T,U,V](typedExp(inner,innerType,retCl),MethodHandleExp(dynMethod(innerMethod,cl,innerType)))
+  
+  def typedExp[T<:AnyRef,U](exp:AST.Exp,cl:Class[T],retClass:Class[U]):Exp[T,U] = exp match {
+    case AST.ThisExp => typedThisExp(cl,retClass)
+    case p@AST.ParentExp(inner,parent) => {
+      val innerMethod = p.method(cl)
+      val innerType:Class[AnyRef] = innerMethod.getReturnType.asInstanceOf[Class[AnyRef]] //TODO: check that here
+      typedParentExp(inner,innerMethod,cl,innerType,retClass)
+    }
+    case e:AST.Exp => MethodHandleExp(dynMethod[T,U](e.method(cl),cl,retClass))
+  }
+  
+  def typedExpandArray[T<:AnyRef,E<:AnyRef](exp:AST.Exp,sep:String,inner:AST.FormatElementList,cl:Class[T],eleClass:Class[E])
+  		:ExpandArray[T,E]
+    = ExpandArray(typedExp(exp,cl,classOfArray(eleClass)),sep,typed(inner,eleClass))
+    
+  def typedConditionalOption[T<:AnyRef,U<:AnyRef](c:AST.Conditional,cl:Class[T],eleClass:Class[U]):ConditionalOption[T,U] = {
+    val AST.Conditional(exp,thenB,elseB) = c
+    ConditionalOption(typedExp(exp,cl,classOf[Option[U]]),typed(thenB,eleClass),typed(elseB,cl))
+  }
+  
+  def typed[T<:AnyRef](ast:AST.FormatElementList,cl:Class[T]):FormatElementList[T] = FormatElementList[T](
+    ast.elements.map {
+      case AST.Literal(str) => Literal(str)
+      case AST.ToStringConversion(exp) => ToStringConversion(typedExp(exp,cl,classOf[AnyRef]))
+      case AST.Expand(exp,sep,inner) => {
+        val eleType:Class[AnyRef] = exp.returnType(cl).getComponentType.asInstanceOf[Class[AnyRef]]
+        if (eleType == null)
+          throw new RuntimeException(exp+" must evaluate into an array but is "+exp.returnType(cl))
+        
+        typedExpandArray(exp,sep,inner,cl,eleType)
+      }
+      case c@AST.Conditional(exp,_,_) => {
+        if (classOf[Option[_]].isAssignableFrom(exp.returnType(cl))){
+          val eleType = elementType(exp.genericReturnType(cl),classOf[Option[_]])
+          typedConditionalOption(c,cl,eleType)
+        }
+        else
+          throw new RuntimeException("Only Option conditionals supported")
+      }
+    }
+  )
+  
+  def classOfArray[T<:AnyRef](eleClass:Class[T]):Class[Array[T]] = Class.forName("[L"+eleClass.getName+";").asInstanceOf[Class[Array[T]]]
+  def elementType(it:java.lang.reflect.Type,of:Class[_])
+  	:Class[_ <: AnyRef] = {
+    TypeHelper.genericInstanceType(it,of,Array()) match{
+      case Some(cl:java.lang.Class[AnyRef]) => cl
+      case _ => throw new java.lang.Error("Can't get element type of "+it)
+    }
+  }
+}
+case class Person(name:String,town:String)
+object IterableHelper {
+  implicit def java2scala[T](it:java.lang.Iterable[T]):Iterable[T] = new Iterable[T]{
+    override def elements:Iterator[T] = new Iterator[T]{
+      val underlying = it.iterator
+      override def hasNext = underlying.hasNext
+      override def next = underlying.next
+    }
+  }
+}
+
+/*
+import net.virtualvoid.string._
+val ast = EnhancedStringFormatParser parse "#this[#name lives in #town]{,}*"
+TypedAST.typed(ast,classOf[Array[Person]])
+ 
+ */
