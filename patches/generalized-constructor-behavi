Bottom: 06d18ba1e34e991e5180ca7ad0934dfbe44d247c
Top:    38fed94c92920c835265b4bbdea42e83fa49a313
Author: Johannes Rudolph <johannes_rudolph@gmx.de>
Date:   2010-11-29 10:19:43 +0100

generalized constructor behavior using local variables for stack manipulation


---

diff --git a/bytecode/src/main/scala/net/virtualvoid/bytecode/Bytecode.scala b/bytecode/src/main/scala/net/virtualvoid/bytecode/Bytecode.scala
index 5617e12..ceb7bf5 100644
--- a/bytecode/src/main/scala/net/virtualvoid/bytecode/Bytecode.scala
+++ b/bytecode/src/main/scala/net/virtualvoid/bytecode/Bytecode.scala
@@ -9,7 +9,7 @@ object Bytecode{
     override def equals(o:Any) = v.equals(o)
   }
   
-  object Instructions {
+  object Instructions extends InstantiationInstructions {
     def withLocal[T,ST<:List,ST2<:List](code:Local[T]=>F[ST]=>F[ST2]):F[ST**T]=>F[ST2] = 
       f => f.withLocal_int[T,ST,ST2](f.stack.top,f.stack.rest,code)
     
diff --git a/bytecode/src/main/scala/net/virtualvoid/bytecode/Instantiation.scala b/bytecode/src/main/scala/net/virtualvoid/bytecode/Instantiation.scala
new file mode 100644
index 0000000..677ae94
--- /dev/null
+++ b/bytecode/src/main/scala/net/virtualvoid/bytecode/Instantiation.scala
@@ -0,0 +1,26 @@
+package net.virtualvoid.bytecode
+
+import scala.reflect.Code
+import java.lang.reflect.{ Constructor => jConstructor }                        
+
+trait Constructor {
+  def constructor: jConstructor[_]
+  def numParams: Int
+}
+
+case class Ctor1[T, U](override val constructor: jConstructor[_]) extends Constructor {
+  override val numParams = 1
+
+  import Bytecode.Instructions._
+  def apply[R <: List](/*arg1: F[Nil] => F[Nil**T]*/): F[R**T] => F[R**U] =
+    withLocal { arg1 => f =>
+      (f.new_int(constructor.getDeclaringClass) ~
+        dup ~
+        arg1.load)
+        .invokeconstructor(this)
+    }
+}
+
+trait InstantiationInstructions {
+  def ctor1[T, U](c: Code[T => U]): Ctor1[T, U] = Ctor1[T, U](CodeTools.constructorFromTree(c.tree))
+}
diff --git a/bytecode/src/main/scala/net/virtualvoid/bytecode/Tools.scala b/bytecode/src/main/scala/net/virtualvoid/bytecode/Tools.scala
index 7a185bd..14c8c1b 100644
--- a/bytecode/src/main/scala/net/virtualvoid/bytecode/Tools.scala
+++ b/bytecode/src/main/scala/net/virtualvoid/bytecode/Tools.scala
@@ -2,7 +2,7 @@ package net.virtualvoid.bytecode
 
 object CodeTools{
   import _root_.scala.reflect._
-  import _root_.java.lang.reflect.{Method=>jMethod}
+  import _root_.java.lang.reflect.{Method=>jMethod, Constructor}
   
   def cleanClass(name:String):java.lang.Class[_] = name match{
     case "int" => Integer.TYPE
@@ -56,9 +56,9 @@ object CodeTools{
     val index = method.lastIndexOf(".")
     (method.substring(0,index),method.substring(index+1))
   }
-  
+  def classNotFound(clazz:String) = new java.lang.Error("clazz missing: " +clazz)//+" in " + tree.toString) 
   def methodFromTree(tree:Tree):jMethod = try {
-        def classNotFound(clazz:String) = new java.lang.Error("clazz missing: " +clazz+" in " + tree.toString) 
+
 	    tree match {/*
 	      // method call if receiver is too generic, i.e. only a bounded type parameter in the enclosing scope
 	      // like [T,It<:Iterable[T]] (it:It) => it.iterator
@@ -102,6 +102,17 @@ object CodeTools{
   catch{
     case e:Exception => throw new Error("Error while calling method: "+tree,e);
   }
+
+  def constructorFromTree(tree: Tree) = tree match {
+    case Function(List(x@LocalValue(_,_,tpe)),Apply(Select(New(Ident(Class(clazz))),Method(method, _)),List(Ident(x1)))) if x == x1 => 
+      //val clazz = extractClass(typeOfQualifier(qual))
+      val cl = forName(clazz).getOrElse(throw classNotFound(clazz))
+      val methodName = method.substring(method.lastIndexOf(".")+1)
+      val argCl = cleanClass(extractClass(tpe))
+      val c = cl.getConstructor(argCl)
+      assert (!static_?(c))
+      c
+  }
   
   import java.lang.reflect.{Member,Modifier}
   def static_?(m:Member):Boolean = (m.getModifiers & Modifier.STATIC) == Modifier.STATIC
diff --git a/bytecode/src/main/scala/net/virtualvoid/bytecode/backend/ASM.scala b/bytecode/src/main/scala/net/virtualvoid/bytecode/backend/ASM.scala
index 143fc9b..40b88ac 100644
--- a/bytecode/src/main/scala/net/virtualvoid/bytecode/backend/ASM.scala
+++ b/bytecode/src/main/scala/net/virtualvoid/bytecode/backend/ASM.scala
@@ -158,6 +158,19 @@ object ASM extends ByteletCompiler{
                           ,Type.getMethodDescriptor(m))
         withStack(stackClass.popN(handle.numParams) ** m.getReturnType)
       }
+      def invokeconstructor[R<:List,U](cons: Constructor)
+                                   :F[R**U] = {
+        val cl = cons.constructor.getDeclaringClass
+        mv.visitMethodInsn(INVOKESPECIAL
+                          ,Type.getInternalName(cl)
+                          ,"<init>"
+                          ,Type.getConstructorDescriptor(cons.constructor))
+        withStack(stackClass.popN(cons.numParams) ** cl)
+      }
+      def new_int[R <: List, U](cl: Class[U]): F[R**U] = {
+        mv.visitTypeInsn(NEW,Type.getInternalName(cl))
+        withStack(stackClass ** cl)
+      }
                                    
       def getstatic_int[ST2>:ST<:List,T](code:scala.reflect.Code[()=>T]):F[ST2**T] = {
         val field = fieldFromTree(code.tree)
diff --git a/bytecode/src/main/scala/net/virtualvoid/bytecode/backend/BackendSupport.scala b/bytecode/src/main/scala/net/virtualvoid/bytecode/backend/BackendSupport.scala
index bccf672..c87a2ec 100644
--- a/bytecode/src/main/scala/net/virtualvoid/bytecode/backend/BackendSupport.scala
+++ b/bytecode/src/main/scala/net/virtualvoid/bytecode/backend/BackendSupport.scala
@@ -25,6 +25,8 @@ trait BackendSupport[+ST <: List] {
     def dup_x1_int[R<:List,T1,T2](rest:R,t2:T2,t1:T1):F[R**T1**T2**T1]
 
     def invokemethod[R<:List,U](handle:MethodHandle):F[R**U]
+    def invokeconstructor[R<:List,U](cons: Constructor): F[R**U]
+    def new_int[R <: List, U](cl: Class[U]): F[R**U]
                                    
     def getstatic_int[ST2>:ST<:List,T](code:scala.reflect.Code[()=>T]):F[ST2**T]
     def putstatic_int[R<:List,T](rest:R,top:T,code:scala.reflect.Code[T=>Unit]):F[R]
diff --git a/bytecode/src/main/scala/net/virtualvoid/bytecode/backend/Interpreter.scala b/bytecode/src/main/scala/net/virtualvoid/bytecode/backend/Interpreter.scala
index 6e1fd8e..f886fec 100644
--- a/bytecode/src/main/scala/net/virtualvoid/bytecode/backend/Interpreter.scala
+++ b/bytecode/src/main/scala/net/virtualvoid/bytecode/backend/Interpreter.scala
@@ -6,6 +6,8 @@ import Bytecode._
 import java.lang.{String=>jString}
 
 object Interpreter extends ByteletCompiler {
+    case object UninitializedObject
+
     case class IF[+ST<:List](stack:ST) extends F[ST]{
       import CodeTools._
       
@@ -42,6 +44,19 @@ object Interpreter extends ByteletCompiler {
         val (args,rest) = popN(handle.numParams)
         IF(rest.asInstanceOf[R] ** invokeMethod(handle.method,args:_*).asInstanceOf[U])
       }
+      /* Try to mimic the normal JVM behaviour here:
+       * new_int pushes a dummy object on the stack, which then should
+       * be DUPlicated by the calling method (otherwise the newly generated object
+       * would be lost instantly).
+       * invokeconstructor then dismisses both instances of UninitializedObject before
+       * using reflection to call the constructor.
+       */
+      override def new_int[R <: List, U](cl: Class[U]): F[R**U] = IF(stack.asInstanceOf[R] ** UninitializedObject.asInstanceOf[U]) // noop
+      override def invokeconstructor[R<:List,U](cons: Constructor): F[R**U] =
+        popN(cons.numParams) match {
+           case (args, Cons(Cons(rest, UninitializedObject), UninitializedObject)) =>
+             IF(rest.asInstanceOf[R] ** cons.constructor.newInstance(args: _*).asInstanceOf[U])
+        }
 
       def getstatic_int[ST2>:ST<:List,T](code:scala.reflect.Code[()=>T]):F[ST2**T] = 
         IF(stack ** fieldFromTree(code.tree).get(null).asInstanceOf[T])
diff --git a/bytecode/src/test/scala/net/virtualvoid/bytecode/BytecodeCompilerSpecs.scala b/bytecode/src/test/scala/net/virtualvoid/bytecode/BytecodeCompilerSpecs.scala
index 27544c6..0c022e5 100644
--- a/bytecode/src/test/scala/net/virtualvoid/bytecode/BytecodeCompilerSpecs.scala
+++ b/bytecode/src/test/scala/net/virtualvoid/bytecode/BytecodeCompilerSpecs.scala
@@ -109,6 +109,12 @@ object BytecodeCompilerSpecs extends Specification{
       compiler.compile(classOf[java.lang.String])(str => _~str.load~dup~newInstance(classOf[java.lang.StringBuilder])~swap()~append~swap()~append~toString)
       .apply("test") must be_==("testtest") 
     }
+    "create new StringBuilder with parameter" in {
+      val ctor = ctor1(new java.lang.StringBuilder(_: String))
+
+      compiler.compile(classOf[java.lang.String])(str => _~str.load~ctor()~toString)
+      .apply("test") must be_==("test") 
+    }
     "store(_) string after void method" in {
       compiler.compile(classOf[java.lang.String])(str => 
         _ ~ 
diff --git a/bytecode/src/test/scala/net/virtualvoid/bytecode/ReflectSpecs.scala b/bytecode/src/test/scala/net/virtualvoid/bytecode/ReflectSpecs.scala
index 4c80d96..9e8f631 100644
--- a/bytecode/src/test/scala/net/virtualvoid/bytecode/ReflectSpecs.scala
+++ b/bytecode/src/test/scala/net/virtualvoid/bytecode/ReflectSpecs.scala
@@ -32,5 +32,13 @@ object ReflectSpecs extends Specification {
 	    m.getParameterTypes.length must be_==(1)
 	  }
 	}
+        "Constructors should be correctly inferred from scala.reflect.Code tree" in {
+          "unary constructors" in {
+	    val c = constructorFromTree(lift(new java.lang.StringBuilder(_: String)).tree)
+	    c.getName must be_==("java.lang.StringBuilder")
+	    c.getParameterTypes.length must be_==(1)
+            c.newInstance("bla").asInstanceOf[java.lang.StringBuilder].toString must be_==("bla")
+	  }
+        }
 }
 //class ReflectSpecsTest extends runner.JUnit4(ReflectSpecs)
